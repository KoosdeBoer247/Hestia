"""


Last Modified: 2025-10-28

=============================================================================
#
#                      HESTIA
#        (Heat Exposure Stress & Thermophysiology Integrated Assessment)
#
# This script combines two specialized simulation models:
# 1. A model for adults.
# 2. A model for children and adolescents.
#
# The user can choose at the beginning which simulation to run.
# The script then automatically adjusts the physiological parameters,
# activity levels (MET values), and perception models (RPE scales).
#
# --- COMMON FEATURES ---
# - JOS-3 Thermoregulation Model: Multi-node model as the core.
# - Monte Carlo Simulation: For population-based risk analysis.
# - Advanced Environmental Modeling: Weather data (NOW OPEN-METEO), 
#   solar radiation (pvlib), and the Urban Heat Island (UHI) effect.
# - Vanos et al. (2023) Integration: Includes survivability (lethal core
#   temperature) and liveability (maximum safe activity) limits.
#
# --- SPECIFIC ADJUSTMENTS (MODE-DEPENDENT) ---
#
# A) ADULT MODE:
#    - Psychobiological Model: Borg RPE Scale (6-20).
#    - Adaptation Profile: Detailed settings for training and
#      heat acclimatization that influence running economy, sweat response,
#      and thirst stimulus.
#    - Water Balance: 'Ad libitum' drinking strategy for adults.
#    - NEW: Post-simulation analysis of safe MET levels for different
#      core temperature thresholds by age and gender.
#
# B) CHILDREN MODE:
#    - Pediatric Physiology: Higher surface-to-mass ratio,
#      lower sweat capacity, and higher metabolic cost.
#    - Psychobiological Model: Children's OMNI RPE Scale (0-10).
#    - Behavioral Model: Accounts for a blunted thirst response
#      ("voluntary dehydration").
#    - Fitness Profile: A simplified 'fitness factor' influences the
#      overall response to exercise and heat.
#
# --- CHANGES IN THIS VERSION (rev02 logic base) ---
# - IMPLEMENTED: Advanced RPE Models (Adult & Pediatric)
#   - Replaced simple linear RPE calculations with new,
#     physiologically-validated functions:
#     - `calculate_adult_rpe_improved`
#     - `calculate_pediatric_rpe_improved`
#   - These models provide a more accurate, piecewise-linear mapping of
#     MET, core temperature, training, acclimatization, and motivation.
# - TRANSLATION: Full script translation to English.
#   - All user-facing prompts (input/print), inline comments,
#     plot labels, and docstrings are now in English.
# - EXPANSION: Docstrings have been expanded for clarity.
# - MAINTAINED: Precision for risk output (4 decimals).
# - MAINTAINED: Detailed Excel export for all virtual participants.
#
# --- OPEN-METEO INTEGRATION NOTES ---
# - No API key is required.
# - get_lat_lon, get_weather_forecast, and get_air_quality
#   use the Open-Meteo APIs.
# - get_weather_forecast transforms the output to remain 100%
#   compatible with the existing interpolate_weather function.
#
=============================================================================
"""

import requests
import pandas as pd
from datetime import datetime, UTC, timedelta
import pytz
from timezonefinder import TimezoneFinder
import pvlib
import math
from pythermalcomfort.models import JOS3
from pythermalcomfort.models import utci, wbgt
from pythermalcomfort.utilities import wet_bulb_tmp
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import numpy as np
from functools import lru_cache
import multiprocessing
from multiprocessing import Pool
from tqdm import tqdm
from colorama import init, Fore, Style
import seaborn as sns
import random
import os
# NEW: Import the required library for Excel
try:
    from openpyxl import load_workbook
except ImportError:
    print(f"{Fore.YELLOW}Warning: 'openpyxl' is not installed. Excel export will not work.{Style.RESET_ALL}")
    print(f"{Fore.YELLOW}Install it with: pip install openpyxl{Style.RESET_ALL}")


print("Script started")


def wind_speed_at_height(v_ref, z_ref, z_target, z0=0.1):
    """
    Converts wind speed from a reference height to a target height
    using the logarithmic wind profile.
    
    Parameters:
    -----------
    v_ref : float
        Wind speed at reference height (m/s).
    z_ref : float
        Reference height (m), e.g., 10m for weather station.
    z_target : float
        Target height (m), e.g., 1.5m for a person.
    z0 : float
        Roughness length (m), default 0.1 for open terrain.
    
    Returns:
    --------
    float : Wind speed at target height (m/s).
    """
    if z_ref <= 0 or z_target <= 0 or z0 <= 0:
        raise ValueError("Heights and roughness length must be positive.")
    return v_ref * (np.log(z_target / z0) / np.log(z_ref / z0))


# No API key needed for Open-Meteo
# --- MET values for adults ---
MET_ACTIVITIES_ADULT = {
    1: {"description": "Jogging, 8 km/h (recreational)", "met": 8.3, "speed_kmh": 8.0},
    2: {"description": "Running, 9.6 km/h (recreational)", "met": 9.8, "speed_kmh": 9.6},
    3: {"description": "Running, 11.2 km/h (recreational)", "met": 11.0, "speed_kmh": 11.2},
    4: {"description": "Running, 12.8 km/h (recreational)", "met": 11.8, "speed_kmh": 12.8},
    5: {"description": "Trail running, moderate pace (recreational)", "met": 9.0, "speed_kmh": 9.0},
    6: {"description": "Running, 13.8 km/h (professional)", "met": 12.3, "speed_kmh": 13.8},
    7: {"description": "Running, 16 km/h (professional)", "met": 14.5, "speed_kmh": 16.0},
    8: {"description": "Running, 19.2 km/h (professional)", "met": 16.0, "speed_kmh": 19.2},
    9: {"description": "Interval sprints, high intensity (professional)", "met": 18.0, "speed_kmh": 20.0},
    10: {"description": "Marathon, competition pace (professional)", "met": 13.5, "speed_kmh": 15.0},
    11: {"description": "Running, average (general)", "met": 10.0, "speed_kmh": 10.0},
    12: {"description": "Walking, 3.2 km/h (slow, recreational)", "met": 2.8, "speed_kmh": 3.2},
    13: {"description": "Walking, 4.0 km/h (moderate, recreational)", "met": 3.5, "speed_kmh": 4.0},
    14: {"description": "Walking, 4.8 km/h (brisk, recreational)", "met": 4.3, "speed_kmh": 4.8},
    15: {"description": "Walking, 5.6 km/h (fast, fitness)", "met": 5.0, "speed_kmh": 5.6},
    16: {"description": "Walking, 6.4 km/h (very fast, fitness)", "met": 6.0, "speed_kmh": 6.4},
    17: {"description": "Walking uphill, 4.0 km/h (3-5% incline)", "met": 5.3, "speed_kmh": 4.0},
    18: {"description": "Walking with backpack, 4.0 km/h (moderate)", "met": 4.5, "speed_kmh": 4.0},
    19: {"description": "Sitting outdoors", "met": 1.2, "speed_kmh": 0.0}
}

# --- MET values for children ---
MET_ACTIVITIES_CHILD = {
    # Ages 0-10 (Focus on Play and School)
    1: {"description": "Sitting quietly (e.g., classroom)", "met": 1.3, "speed_kmh": 0.0},
    2: {"description": "Walking slowly (e.g., to school)", "met": 2.5, "speed_kmh": 3.0},
    3: {"description": "Light play (e.g., sandbox, standing activity)", "met": 3.0, "speed_kmh": 1.0},
    4: {"description": "Active play / General gymnastics", "met": 4.0, "speed_kmh": 2.0},
    5: {"description": "Running / Very active play (e.g., tag)", "met": 6.0, "speed_kmh": 6.0},

    # Ages 11-20 (Focus on Sports and Recreation)
    6: {"description": "Walking, brisk pace", "met": 3.8, "speed_kmh": 5.0},
    7: {"description": "Cycling, leisurely pace", "met": 4.0, "speed_kmh": 12.0},
    8: {"description": "Soccer, casual / kickabout", "met": 7.0, "speed_kmh": 7.0},
    9: {"description": "Basketball, shooting baskets", "met": 4.5, "speed_kmh": 3.0},
    10: {"description": "Jogging, moderate pace", "met": 8.0, "speed_kmh": 9.0}
}

# --- Clothing options for adults ---
CLO_OPTIONS_ADULT = {
    1: {"description": "Shorts and T-shirt (summer)", "clo": 0.2},
    2: {"description": "Shorts and tank top (very light)", "clo": 0.1},
    3: {"description": "Long pants and T-shirt (mild weather)", "clo": 0.4},
    4: {"description": "Long pants and long sleeves (cool weather)", "clo": 0.6},
    5: {"description": "Running jacket and long pants (cold weather)", "clo": 0.8},
    6: {"description": "Thermal underwear and jacket (winter)", "clo": 1.0}
}

# --- Clothing options for children ---
CLO_OPTIONS_CHILD = {
    1: {"description": "Shorts and T-shirt (summer)", "clo": 0.2},
    2: {"description": "Shorts and tank top (very light)", "clo": 0.1},
    3: {"description": "School uniform (trousers/skirt, polo shirt)", "clo": 0.4},
    4: {"description": "Tracksuit / long sleeves (cool weather)", "clo": 0.6},
    5: {"description": "Light jacket and long pants (cold weather)", "clo": 0.8},
}

# Data estimated from Fig. 4a & 4b in Vanos et al., Nature Communications (2023)
# Key: (air_temp, relative_humidity) -> Value: Max safe MET (M_max)
LIVEABILITY_LIMITS = {
    'young_adult_shaded': {
        (25, 90): 5.0, (25, 50): 7.0, (25, 20): 8.4,
        (30, 90): 3.5, (30, 50): 5.5, (30, 20): 7.0,
        (35, 90): 1.5, (35, 50): 4.0, (35, 20): 5.8,
        (40, 70): 1.5, (40, 40): 3.0, (40, 10): 5.0,
        (45, 40): 1.5, (45, 10): 3.8,
        (50, 20): 2.0, (50, 10): 3.0,
    },
    'older_adult_shaded': {
        (25, 90): 4.2, (25, 50): 5.9, (25, 20): 6.8,
        (30, 90): 2.8, (30, 50): 4.5, (30, 20): 5.5,
        (35, 90): 1.5, (35, 50): 3.0, (35, 20): 4.2,
        (40, 60): 1.5, (40, 30): 2.2, (40, 10): 3.4,
        (45, 25): 1.5, (45, 10): 2.5,
        (50, 10): 1.8
    }
}

def get_liveability_threshold(temp, rh, age):
    """
    Gets the M_max (maximum safe MET value) from the Vanos et al. (2023)
    lookup table. Uses the nearest value if there is no exact match.
    
    Parameters:
    -----------
    temp : float
        Air temperature (°C).
    rh : float
        Relative humidity (%).
    age : int
        Participant age.
    
    Returns:
    --------
    float : Maximum safe MET (M_max).
    """
    # Use >65 for older adults as per Vanos et al.
    profile = 'older_adult_shaded' if age > 65 else 'young_adult_shaded'
    data = LIVEABILITY_LIMITS[profile]

    # Find the nearest data point based on a simple distance metric
    # Note: RH has less weight in the distance calculation
    closest_point = min(data.keys(), key=lambda k: abs(k[0] - temp) + abs(k[1] - rh) / 5) 
    return data[closest_point]


def calculate_uhi_effect(population, wind_speed, is_daytime):
    """
    Calculates the Urban Heat Island (UHI) effect based on Oke's formula.
    
    This simplified model estimates the temperature increase (°C)
    based on population (logarithmically) and wind speed (inversely).
    The effect is stronger at night (less mixing, stored heat release).
    
    Parameters:
    -----------
    population : int
        City population.
    wind_speed : float
        Wind speed (m/s) at 10m.
    is_daytime : bool
        True if daytime (6:00-18:00), False if nighttime.
        
    Returns:
    --------
    float : Estimated UHI effect in °C.
    """
    if population < 1000:
        return 0.0
    
    # Base UHI from population (Oke, 1973)
    uhi_base = 2.0 * math.log10(population) - 4.0
    uhi_base = max(0.0, min(8.0, uhi_base)) # Cap at 0 and 8°C
    
    # Wind factor reduces UHI
    wind_factor = max(0.0, 1.0 - 0.1 * wind_speed)
    
    # Time factor (UHI is stronger at night)
    time_factor = 0.5 if is_daytime else 1.0
    
    return round(uhi_base * wind_factor * time_factor, 2)


# =============================================================================
#                    SIMULATION FUNCTIONS FOR ADULTS
# =============================================================================

def simulate_runner(n_simulations=200, met_value=None, training_factor=0.0, acclimatization_factor=0.0):
    """
    Generates realistic variations for adult participants for Monte Carlo simulation.
    
    This function creates a population of virtual runners, applying
    physiological adjustments based on the selected training and
    acclimatization profiles.
    
    Parameters:
    -----------
    n_simulations : int
        Number of virtual participants to generate.
    met_value : float
        The base MET value for the chosen activity.
    training_factor : float (0.0 to 1.0)
        Training status (0=untrained, 1=elite).
    acclimatization_factor : float (0.0 to 1.0)
        Heat acclimatization status (0=unacclimatized, 1=fully).
        
    Returns:
    --------
    list of tuples :
        A list where each tuple contains the parameters for one virtual runner.
        (height, weight, temp_variation, rh_variation, met_variation,
         mf_score, sweat_factor, thirst_threshold, gender)
    """
    valid_simulations = []
    attempts = 0
    max_attempts = n_simulations * 25 # Try max 25 times per valid sim

    print("\nGenerating realistic adult participant profiles based on adaptation profile...")
    while len(valid_simulations) < n_simulations and attempts < max_attempts:
        attempts += 1

        # Anthropometrics
        height = np.clip(np.random.normal(loc=1.75, scale=0.08), 1.5, 2.0)
        weight = np.clip(np.random.normal(loc=70, scale=10), 50, 100)
        bmi = weight / (height ** 2)
        if not (18.0 <= bmi <= 35.0):
            continue # Filter out unrealistic BMIs

        # Individual perception/variation for environment
        temp_variation = np.random.normal(loc=0, scale=1.5)
        rh_variation = np.random.normal(loc=0, scale=3)

        # Metabolic efficiency: Training improves economy (lower MET for same speed)
        met_efficiency_offset = -training_factor * met_value * 0.15  # Up to 15% more efficient
        met_variation = np.random.normal(loc=met_efficiency_offset, scale=0.05 * met_value)
        final_met = met_value + met_variation
        if final_met < max(1.5, met_value * 0.75):
            continue # Ensure MET doesn't become unrealistically low

        # Psychological factor
        mf_score = np.random.uniform(0.0, 1.0)

        # Sweat factor: Acclimatized individuals sweat more (higher factor)
        sweat_loc = 0.8 + (acclimatization_factor * 0.3) # Max ~1.1
        sweat_factor = np.random.normal(loc=sweat_loc, scale=0.15)

        # Thirst threshold: Acclimatized individuals drink earlier (lower % dehydration threshold)
        thirst_upper_bound = 2.5 - (acclimatization_factor * 1.0) # Down to ~1.5%
        thirst_threshold = np.random.uniform(1.0, max(1.1, thirst_upper_bound))

        # Generate gender for the participant
        gender = random.choice(["male", "female"])

        valid_simulations.append((height, weight, temp_variation, rh_variation, met_variation,
                                 mf_score, sweat_factor, thirst_threshold, gender))

    if len(valid_simulations) < n_simulations:
        print(f"{Fore.YELLOW}Warning: Could only generate {len(valid_simulations)}/{n_simulations} realistic simulations.{Style.RESET_ALL}")
    else:
        print(f"{Fore.GREEN}Successfully generated {len(valid_simulations)} realistic simulations.{Style.RESET_ALL}")

    return valid_simulations

# =============================================================================
#                    SIMULATION FUNCTIONS FOR CHILDREN
# =============================================================================

def simulate_child_participant(n_simulations=200, met_value=None, age_group="11-20", fitness_factor=0.5):
    """
    Generates realistic variations for pediatric participants for Monte Carlo simulation.
    
    This function creates a population of virtual children, adjusting
    anthropometrics based on age group and physiology based on fitness.
    
    Parameters:
    -----------
    n_simulations : int
        Number of virtual participants to generate.
    met_value : float
        The base MET value for the chosen activity.
    age_group : str
        "0-10" or "11-20" to set height/weight distributions.
    fitness_factor : float (0.0 to 1.0)
        Simplified factor for training/adaptation.
        
    Returns:
    --------
    list of tuples :
        A list where each tuple contains the parameters for one virtual child.
        (height, weight, temp_variation, rh_variation, met_variation, 
         mf_score, sweat_factor, thirst_threshold)
    """
    valid_simulations = []
    attempts = 0
    max_attempts = n_simulations * 25

    # Set anthropometric means/SDs based on age group
    if age_group == "0-10":
        height_mean, height_sd = 1.22, 0.08
        weight_mean, weight_sd = 23.0, 4.0
    else:  # 11-20
        height_mean, height_sd = 1.65, 0.1
        weight_mean, weight_sd = 55.0, 10.0

    print(f"\nGenerating realistic pediatric participant profiles for age group {age_group}...")
    while len(valid_simulations) < n_simulations and attempts < max_attempts:
        attempts += 1

        # Anthropometrics
        height = np.clip(np.random.normal(loc=height_mean, scale=height_sd), height_mean - 0.3, height_mean + 0.3)
        weight = np.clip(np.random.normal(loc=weight_mean, scale=weight_sd), weight_mean - 15.0, weight_mean + 15.0)
        bmi = weight / (height ** 2)
        if not (14.0 <= bmi <= 30.0):
            continue # Filter out unrealistic BMIs

        # Individual perception/variation
        temp_variation = np.random.normal(loc=0, scale=1.0)
        rh_variation = np.random.normal(loc=0, scale=8.0) # Higher RH variation assumed

        # Metabolic efficiency: Fitness improves economy (less)
        met_efficiency_offset = (1 - fitness_factor) * met_value * 0.10 # Less efficient
        met_variation = np.random.normal(loc=met_efficiency_offset, scale=0.05 * met_value)

        # Psychological factor
        mf_score = np.random.uniform(0.0, 1.0)

        # Sweat factor: Children sweat less effectively.
        sweat_loc = 0.5 + (fitness_factor * 0.2)
        sweat_factor = np.clip(np.random.normal(loc=sweat_loc, scale=0.1), 0.3, 0.9)

        # Thirst threshold: Children have a blunted thirst response (higher % threshold)
        thirst_upper_bound = 3.5 - (fitness_factor * 1.0)
        thirst_threshold = np.random.uniform(2.0, max(2.1, thirst_upper_bound))

        valid_simulations.append((height, weight, temp_variation, rh_variation, met_variation, mf_score, sweat_factor, thirst_threshold))

    if len(valid_simulations) < n_simulations:
        print(f"{Fore.YELLOW}Warning: Could only generate {len(valid_simulations)}/{n_simulations} realistic simulations.{Style.RESET_ALL}")
    else:
        print(f"{Fore.GREEN}Successfully generated {len(valid_simulations)} realistic simulations.{Style.RESET_ALL}")

    return valid_simulations

# =============================================================================
#                    COMMON ENVIRONMENTAL FUNCTIONS
# =============================================================================

@lru_cache(maxsize=128)
def get_lat_lon(city_name):
    """
    Retrieves latitude and longitude for a given city using the
    Open-Meteo Geocoding API.
    
    Parameters:
    -----------
    city_name : str
        The name of the city (e.g., "Amsterdam").
        
    Returns:
    --------
    tuple : (float, float) or (None, None)
        (latitude, longitude) or (None, None) if not found.
    """
    try:
        geo_url = f"https://geocoding-api.open-meteo.com/v1/search?name={city_name}&count=1&format=json"
        response = requests.get(geo_url, timeout=10)
        response.raise_for_status()
        data = response.json()
        if data and "results" in data and len(data["results"]) > 0:
            return data["results"][0]["latitude"], data["results"][0]["longitude"]
        else:
            return None, None
    except requests.RequestException as e:
        print(f"Error fetching location: {e}")
        return None, None


@lru_cache(maxsize=128)
def get_timezone(lat, lon):
    """
    Determines the IANA timezone name for a given latitude and longitude.
    
    Parameters:
    -----------
    lat : float
        Latitude.
    lon : float
        Longitude.
        
    Returns:
    --------
    pytz.timezone
        The timezone object (defaults to UTC if not found).
    """
    tf = TimezoneFinder()
    timezone_name = tf.timezone_at(lat=lat, lng=lon)
    return pytz.timezone(timezone_name) if timezone_name else pytz.UTC


@lru_cache(maxsize=128)
def get_weather_forecast(lat, lon):
    """
    Retrieves a 7-day hourly weather forecast from the Open-Meteo API.
    
    Transforms the Open-Meteo (column-based) format to the
    (list-of-dicts) format previously used by OpenWeatherMap,
    ensuring compatibility with the rest of the script.
    
    Parameters:
    -----------
    lat : float
        Latitude.
    lon : float
        Longitude.
        
    Returns:
    --------
    list of dicts or None
        A list of hourly weather data points in a structure
        compatible with `interpolate_weather`.
    """
    try:
        # Request 7-day forecast to populate the date picker
        forecast_url = (
            f"https://api.open-meteo.com/v1/forecast?latitude={lat}&longitude={lon}"
            "&hourly=temperature_2m,relative_humidity_2m,wind_speed_10m,cloud_cover,surface_pressure"
            "&forecast_days=7&timezone=UTC"
        )
        response = requests.get(forecast_url, timeout=10)
        response.raise_for_status()
        data = response.json()

        if not data or "hourly" not in data:
            print("No hourly data returned from Open-Meteo.")
            return None

        hourly = data["hourly"]
        
        # Transform Open-Meteo data to the OWM-like structure
        owm_like_list = []
        for i in range(len(hourly["time"])):
            # Convert ISO time string to UTC datetime object, then to Unix timestamp
            dt_str = hourly["time"][i]
            dt_obj = datetime.fromisoformat(dt_str).replace(tzinfo=UTC)
            dt_timestamp = int(dt_obj.timestamp())
            
            # Convert wind speed from km/h (Open-Meteo) to m/s (expected by script)
            wind_speed_ms = hourly["wind_speed_10m"][i] / 3.6
            
            entry = {
                "dt": dt_timestamp,
                "main": {
                    "temp": hourly["temperature_2m"][i],
                    "humidity": hourly["relative_humidity_2m"][i],
                    "pressure": hourly["surface_pressure"][i] # OM pressure is in hPa
                },
                "wind": {
                    "speed": wind_speed_ms
                },
                "clouds": {
                    "all": hourly["cloud_cover"][i]
                }
            }
            owm_like_list.append(entry)
            
        return owm_like_list

    except requests.RequestException as e:
        print(f"Error fetching weather data: {e}")
        return None


def _map_us_aqi_to_owm_scale(us_aqi):
    """
    Maps US AQI (0-500) to the simple 1-5 scale
    previously used by OpenWeatherMap.
    """
    if us_aqi <= 50:  return 1  # Good
    if us_aqi <= 100: return 2  # Moderate
    if us_aqi <= 150: return 3  # Unhealthy for Sensitive
    if us_aqi <= 200: return 4  # Unhealthy
    return 5  # Very Unhealthy / Hazardous


@lru_cache(maxsize=128)
def get_air_quality(lat, lon):
    """
    Retrieves the current Air Quality Index (AQI) using Open-Meteo.
    Maps the US AQI value to a 1-5 scale.
    
    Parameters:
    -----------
    lat : float
        Latitude.
    lon : float
        Longitude.
        
    Returns:
    --------
    int : AQI on a 1-5 scale (1=Good, 5=Hazardous).
    """
    try:
        # Request current US AQI
        air_url = f"https://air-quality-api.open-meteo.com/v1/air-quality?latitude={lat}&longitude={lon}&current=us_aqi&timezone=UTC"
        response = requests.get(air_url, timeout=10)
        response.raise_for_status()
        data = response.json()
        
        us_aqi = data["current"]["us_aqi"]
        
        # Map to the 1-5 scale expected by the script
        return _map_us_aqi_to_owm_scale(us_aqi)
        
    except requests.RequestException as e:
        print(f"Error fetching air quality: {e}")
        return 1 # Fallback to 1 (Good)

@lru_cache(maxsize=256)
def calculate_solar_radiance(lat, lon, local_datetime_str, cloud_cover, aqi):
    """
    Calculates solar radiation components (GHI, DNI, DHI) and solar position
    using pvlib.
    
    Parameters:
    -----------
    lat : float
        Latitude.
    lon : float
        Longitude.
    local_datetime_str : str
        The local time as a string (will be localized).
    cloud_cover : float
        Cloud cover percentage (0-100).
    aqi : int
        Air Quality Index (1-5 scale) to estimate Linke turbidity.
        
    Returns:
    --------
    dict : Contains GHI, DNI, DHI, solar_elevation, and zenith.
    """
    try:
        local_timezone = get_timezone(lat, lon)
        # Ensure the datetime string is timezone-aware for pvlib
        local_datetime = pd.to_datetime(local_datetime_str).tz_convert(local_timezone.zone)
        location = pvlib.location.Location(lat, lon, tz=local_timezone.zone, altitude=0)

        # Get the solar position.
        solar_position = location.get_solarposition(pd.DatetimeIndex([local_datetime]))

        elevation = solar_position['elevation'].iloc[0]
        zenith = solar_position['apparent_zenith'].iloc[0]
        azimuth = solar_position['azimuth'].iloc[0]

        # Estimate Linke turbidity based on AQI
        linke_turbidity = 2.5 if aqi <= 2 else 4.0 if aqi <= 4 else 6.0
        clear_sky = location.get_clearsky(local_datetime, model='ineichen', linke_turbidity=linke_turbidity)

        # Apply cloud cover correction
        cloud_factor = 1 - (cloud_cover / 100)
        cloud_factor = max(0.1, cloud_factor) # Ensure some radiation passes

        dni = clear_sky['dni'].iloc[0] * cloud_factor
        dhi = clear_sky['dhi'].iloc[0] * (1 + (1 - cloud_factor) * 0.5)

        # Calculate GHI from the components
        ghi = dni * pvlib.irradiance.aoi_projection(0, 0, zenith, azimuth) + dhi

        return {'ghi': max(0, ghi), 'dni': max(0, dni), 'dhi': max(0, dhi),
                'solar_elevation': elevation, 'zenith': zenith}
    except Exception as e:
        # Fallback for dates too far in the future where pvlib might fail
        if "year is out of range" in str(e):
             return {'ghi': 0, 'dni': 0, 'dhi': 0, 'solar_elevation': 0, 'zenith': 90}
        print(f"Error calculating solar radiance for {local_datetime_str}: {e}")
        return {'ghi': 0, 'dni': 0, 'dhi': 0, 'solar_elevation': 0, 'zenith': 90}

def calculate_globe_temperature(dry_bulb_temp, ghi, wind_speed, solar_elevation, pressure, cloud_cover, aqi):
    """
    Calculates the temperature of a standard black globe thermometer (150mm)
    based on a full energy balance equation (ISO 7726).
    
    This function iteratively solves the energy balance:
    Solar Gain + Ambient Radiation = Emitted Radiation + Convection Loss
    
    Parameters:
    -----------
    dry_bulb_temp : float
        Air temperature (°C)
    ghi : float
        Global Horizontal Irradiance (W/m²)
    wind_speed : float
        Wind speed at globe height (m/s)
    solar_elevation : float
        Solar elevation angle (degrees)
    pressure : float
        Atmospheric pressure (hPa)
    cloud_cover : float
        Cloud cover (%) - used for night correction
    aqi : int
        Air Quality Index - used for night correction
        
    Returns:
    --------
    float : Globe temperature (°C)
    """
    # Physical constants
    GLOBE_DIAMETER = 0.15          # meters (standard 150mm)
    GLOBE_EMISSIVITY = 0.95        # emissivity of black sphere
    SOLAR_ABSORPTIVITY = 0.95      # absorptivity for solar radiation
    STEFAN_BOLTZMANN = 5.67e-8     # W/(m²·K⁴)
    
    # Convert to Kelvin
    t_air_k = dry_bulb_temp + 273.15
    
    # =================================================================
    # STEP 1: Calculate convection coefficient (ISO 7726)
    # =================================================================
    effective_wind = max(0.1, wind_speed)  # Minimum wind for natural convection
    
    # ISO 7726 formula for forced convection around a sphere:
    h_c = 6.3 * (effective_wind**0.6) / (GLOBE_DIAMETER**0.4)
    
    # =================================================================
    # STEP 2: Handle day/night scenarios
    # =================================================================
    
    # --- NIGHT SCENARIO (no sun) ---
    if ghi <= 0 or solar_elevation <= 0:
        # Estimate effective sky temperature
        # Clear sky: ~8-12K colder than air
        # Cloudy sky: ~2-5K colder than air
        sky_depression = 10 - (cloud_cover / 100) * 6  # 10K (clear) to 4K (cloudy)
        
        # Extra warming from air pollution (aerosols radiate back)
        if aqi > 3:
            sky_depression -= 2
        
        sky_temp_k = t_air_k - sky_depression
        
        # Net radiation loss to sky
        net_radiation = GLOBE_EMISSIVITY * STEFAN_BOLTZMANN * (sky_temp_k**4 - t_air_k**4)
        
        # Globe is slightly cooler than air due to radiation loss
        # Balance: radiation_loss = convection_gain
        delta_t = net_radiation / h_c
        
        t_globe_c = dry_bulb_temp + delta_t
        
        # Reality check: not more than 3°C cooler than air at night
        return max(dry_bulb_temp - 3, min(dry_bulb_temp + 1, t_globe_c))
    
    # --- DAY SCENARIO (with sun) ---
    
    # Solar input per unit area of the sphere (projected area / total area = 1/4)
    solar_input_per_area = SOLAR_ABSORPTIVITY * ghi / 4.0
    
    # Ambient radiation (assumption: T_surr ≈ T_air)
    ambient_radiation = GLOBE_EMISSIVITY * STEFAN_BOLTZMANN * (t_air_k**4)
    
    # Total energy input
    total_energy_in = solar_input_per_area + ambient_radiation
    
    # =================================================================
    # STEP 3: Iteratively solve energy balance (Newton-Raphson)
    # =================================================================
    
    # Initial estimate: linear approximation
    h_r_initial = 4 * GLOBE_EMISSIVITY * STEFAN_BOLTZMANN * (t_air_k**3)
    delta_t_initial = solar_input_per_area / (h_c + h_r_initial)
    t_globe_k = t_air_k + delta_t_initial
    
    max_iterations = 20
    
    for _ in range(max_iterations):
        # Energy OUT (emitted by globe)
        radiation_out = GLOBE_EMISSIVITY * STEFAN_BOLTZMANN * (t_globe_k**4)
        convection_out = h_c * (t_globe_k - t_air_k)
        total_energy_out = radiation_out + convection_out
        
        # Energy balance difference (imbalance)
        imbalance = total_energy_in - total_energy_out
        
        # Check convergence
        if abs(imbalance) < 0.1:  # W/m² (very accurate)
            break
        
        # Derivative of energy_out with respect to T_globe
        derivative = 4 * GLOBE_EMISSIVITY * STEFAN_BOLTZMANN * (t_globe_k**3) + h_c
        
        # Newton-Raphson update
        correction = imbalance / derivative
        
        # Damped update for stability
        damping_factor = 0.7
        t_globe_k = t_globe_k + damping_factor * correction
        
        # Prevent unrealistic values during iteration
        if t_globe_k < t_air_k - 5:
            t_globe_k = t_air_k
        elif t_globe_k > t_air_k + 50:
            t_globe_k = t_air_k + 20
    
    # Convert back to Celsius
    t_globe_c = t_globe_k - 273.15
    
    # =================================================================
    # STEP 4: Reality check (physical limits)
    # =================================================================
    
    # Globe cannot be cooler than air with solar radiation
    if t_globe_c < dry_bulb_temp:
        t_globe_c = dry_bulb_temp
    
    # Maximum realistic temperature rise above air
    max_realistic_delta = 15 if effective_wind > 2.0 else 20
    
    if t_globe_c > dry_bulb_temp + max_realistic_delta:
        t_globe_c = dry_bulb_temp + max_realistic_delta
    
    return t_globe_c


def calculate_mrt(globe_temp, dry_bulb_temp, wind_speed, ghi, solar_elevation):
    """
    Calculates Mean Radiant Temperature (MRT) from globe temperature
    according to ISO 7726.
    
    MRT is derived by removing the convective component from the
    globe's energy balance.
    
    Formula: T_mrt⁴ = T_globe⁴ + (h_c/(ε·σ))·(T_globe - T_air)
    
    Parameters:
    -----------
    globe_temp : float
        Globe temperature (°C)
    dry_bulb_temp : float
        Air temperature (°C)
    wind_speed : float
        Wind speed (m/s)
    ghi : float
        Global Horizontal Irradiance (W/m²) - for validation
    solar_elevation : float
        Solar elevation angle (degrees) - for validation
        
    Returns:
    --------
    float : Mean Radiant Temperature (°C)
    """
    # Constants
    GLOBE_DIAMETER = 0.15
    GLOBE_EMISSIVITY = 0.95
    STEFAN_BOLTZMANN = 5.67e-8
    
    # Convert to Kelvin
    t_globe_k = globe_temp + 273.15
    t_air_k = dry_bulb_temp + 273.15
    
    # Convection coefficient (same as in globe calculation)
    effective_wind = max(0.1, wind_speed)
    h_c = 6.3 * (effective_wind**0.6) / (GLOBE_DIAMETER**0.4)
    
    # =================================================================
    # Calculate MRT according to ISO 7726
    # =================================================================
    
    convection_term = (h_c / (GLOBE_EMISSIVITY * STEFAN_BOLTZMANN)) * (t_globe_k - t_air_k)
    
    mrt_k_fourth_power = (t_globe_k**4) + convection_term
    
    # Prevent negative values (physically impossible)
    if mrt_k_fourth_power < 0:
        return globe_temp # Fallback
    
    mrt_k = mrt_k_fourth_power**0.25
    mrt_c = mrt_k - 273.15
    
    # =================================================================
    # Validation and reality check
    # =================================================================
    
    if ghi > 0 and solar_elevation > 0:
        # DAY: MRT cannot be extremely higher than globe temp
        max_mrt = globe_temp + 15
        min_mrt = globe_temp - 2
        
        if mrt_c > max_mrt:
            mrt_c = max_mrt
        elif mrt_c < min_mrt:
            mrt_c = min_mrt
    else:
        # NIGHT: MRT can be lower than air (cold sky)
        max_mrt = dry_bulb_temp + 3
        min_mrt = dry_bulb_temp - 15
        
        if mrt_c > max_mrt:
            mrt_c = max_mrt
        elif mrt_c < min_mrt:
            mrt_c = min_mrt
    
    # Absolute physical limits
    if mrt_c > 70 or mrt_c < -50:
        # For extreme values: fallback to safe estimate
        return dry_bulb_temp if ghi <= 0 else globe_temp
    
    return mrt_c

def interpolate_weather(weather_data, start_dt, end_dt, interval_minutes=10):
    """
    Interpolates raw hourly weather data to a consistent time-step
    (e.g., 10 minutes) for the simulation.
    
    Parameters:
    -----------
    weather_data : list of dicts
        Raw hourly data from `get_weather_forecast`.
    start_dt : pd.Timestamp
        The simulation start time (timezone-aware).
    end_dt : pd.Timestamp
        The simulation end time (timezone-aware).
    interval_minutes : int
        The desired time step for interpolation.
        
    Returns:
    --------
    list of dicts :
        A list of interpolated weather data points, one for
        each time step in the simulation.
    """
    times = pd.date_range(start=start_dt, end=end_dt, freq=f"{interval_minutes}min")
    times_ts = np.array([t.timestamp() for t in times])

    # Create arrays from the raw weather data
    weather_timestamps = np.array([entry["dt"] for entry in weather_data])
    temps = np.array([entry["main"]["temp"] for entry in weather_data])
    rhs = np.array([entry["main"]["humidity"] for entry in weather_data])
    winds = np.array([entry["wind"]["speed"] for entry in weather_data])
    clouds = np.array([entry["clouds"]["all"] for entry in weather_data])
    pressures = np.array([entry["main"]["pressure"] for entry in weather_data])

    # Interpolate each variable
    interp_temps = np.interp(times_ts, weather_timestamps, temps)
    interp_rhs = np.interp(times_ts, weather_timestamps, rhs)
    interp_winds = np.interp(times_ts, weather_timestamps, winds)
    interp_clouds = np.interp(times_ts, weather_timestamps, clouds)
    interp_pressures = np.interp(times_ts, weather_timestamps, pressures)

    return [
        {
            "time": pd.Timestamp.fromtimestamp(ts, tz=start_dt.tz),
            "temp": temp,
            "rh": rh,
            "wind": wind,
            "clouds": cloud,
            "pressure": pressure,
            "twb": wet_bulb_tmp(tdb=temp, rh=rh)  # Calculate and add Wet Bulb Temperature
        }
        for ts, temp, rh, wind, cloud, pressure in zip(times_ts, interp_temps, interp_rhs, interp_winds, interp_clouds, interp_pressures)
    ]


# =============================================================================
#         *** NEW: ADVANCED PSYCHOBIOLOGICAL RPE MODELS ***
# =============================================================================

def calculate_adult_rpe_improved(current_met, t_rect, training_factor, 
                                     acclimatization_factor, mf_score):
    """
    Calculate Rate of Perceived Exertion (RPE) for adults using the Borg 6-20 scale.
    
    This function implements a physiologically validated model based on:
    - ACSM Guidelines for Exercise Testing (2018)
    - Périard et al. (2011) - Heat stress and RPE
    - Racinais et al. (2015) - Heat acclimatization effects
    - Borg (1982) - Original RPE scale development
    
    The Borg scale correlates with cardiovascular strain (RPE × 10 ≈ heart rate).
    
    Parameters
    ----------
    current_met : float
        Current metabolic equivalent of task (MET).
    t_rect : float
        Rectal (core) body temperature in degrees Celsius.
    training_factor : float
        Training status ranging from 0.0 (untrained) to 1.0 (elite athlete).
    acclimatization_factor : float
        Heat acclimatization status from 0.0 (unacclimatized) to 1.0 (fully acclimatized).
    mf_score : float
        Motivational factor from 0.0 (highly motivated/positive affect) to 1.0 
        (unmotivated/negative affect).
    
    Returns
    -------
    tuple of (float, float)
        rpe_physical : Physical RPE (6-20) without psychological factors
        rpe_total : Total RPE (6-20) including motivational/psychological effects
    
    Notes
    -----
    The function uses a piecewise-linear mapping from MET to RPE to reflect
    the non-linear perception of effort at different exercise intensities.
    Heat stress effects are applied with a threshold at 38.0°C.
    """
    
    # STEP 1: Base RPE from metabolic demand
    # Piecewise-linear mapping reflecting non-linear effort perception
    if current_met <= 2.0:
        # Very light activity (e.g., slow walking)
        base_rpe = 6.0 + (current_met - 1.0) * 2.0  # Range: 6-8
    elif current_met <= 6.0:
        # Light activity (e.g., brisk walking)
        base_rpe = 8.0 + (current_met - 2.0) * 1.0  # Range: 8-12
    elif current_met <= 10.0:
        # Moderate activity (e.g., jogging)
        base_rpe = 12.0 + (current_met - 6.0) * 0.75  # Range: 12-15
    elif current_met <= 14.0:
        # Hard activity (e.g., running)
        base_rpe = 15.0 + (current_met - 10.0) * 0.75  # Range: 15-18
    else:
        # Very hard activity (e.g., sprinting)
        base_rpe = 18.0 + min((current_met - 14.0) * 0.4, 2.0)  # Range: 18-20
    
    # STEP 2: Training adaptation effect
    # Well-trained individuals have improved mechanical efficiency
    training_reduction = training_factor * 0.15  # Max 15% reduction
    adjusted_base = base_rpe * (1.0 - training_reduction)
    
    # STEP 3: Thermal strain effect
    # Heat increases central fatigue and cardiovascular strain
    if t_rect > 38.0:
        heat_penalty_base = (t_rect - 38.0) * 1.8 # ~1 RPE point per 0.5°C
        # Acclimatization reduces thermal strain perception by ~40%
        heat_penalty = heat_penalty_base * (1.0 - acclimatization_factor * 0.4)
    else:
        heat_penalty = 0.0
    
    # Physical RPE (without psychological factors)
    rpe_physical = np.clip(adjusted_base + heat_penalty, 6.0, 20.0)
    
    # STEP 4: Motivational/psychological modulation
    # Psychological state affects effort perception by ±15%
    motivation_modifier = (mf_score - 0.5) * 2.0  # Map [0,1] to [-1,1]
    # Effect is proportional to "room" on the scale (20 - current_RPE)
    motivation_effect = motivation_modifier * (20.0 - rpe_physical) * 0.15
    
    rpe_total = np.clip(rpe_physical + motivation_effect, 6.0, 20.0)
    
    return rpe_physical, rpe_total


def calculate_pediatric_rpe_improved(current_met, t_core, fitness_factor, 
                                         mf_score, age_group):
    """
    Calculate Rate of Perceived Exertion (RPE) for children using the OMNI 0-10 scale.
    
    This function implements a pediatric-specific model based on:
    - Utter et al. (2002) - OMNI scale validation in children
    - Falk et al. (2022) - Thermoregulation in children
    - Bar-Or & Rowland (2004) - Pediatric exercise physiology
    
    The OMNI scale uses child-friendly pictorial anchors.
    
    Parameters
    ----------
    current_met : float
        Current metabolic equivalent of task (MET).
    t_core : float
        Core body temperature in degrees Celsius.
    fitness_factor : float
        Fitness/conditioning level from 0.0 (sedentary) to 1.0 (highly trained).
    mf_score : float
        Motivational factor from 0.0 (highly motivated/enjoying) to 1.0
        (unmotivated/not enjoying).
    age_group : str
        Age category: "0-10" or "11-20"
    
    Returns
    -------
    tuple of (float, float)
        rpe_physical : Physical RPE (0-10) without psychological factors
        rpe_total : Total RPE (0-10) including motivational/affective state
    
    Notes
    -----
    Key differences from adult RPE:
    1. **Relative Intensity**: RPE is based on % of max MET capacity,
       which is lower in children.
    2. **Delayed thermal perception**: Heat stress threshold is higher
       (e.g., 38.2°C-38.3°C) due to immature thermoregulatory awareness.
    3. **Greater psychological influence**: Emotional state has a
       larger (±25%) effect.
    """
    
    # STEP 1: Determine age-appropriate maximum MET capacity
    if age_group == "0-10":
        max_met_capacity = 10.5  # Younger children
        thermal_threshold = 38.3  # Higher threshold (less awareness)
    else:  # "11-20"
        max_met_capacity = 13.0  # Adolescents
        thermal_threshold = 38.2
    
    # Calculate relative intensity (% of maximum capacity)
    relative_intensity = np.clip(current_met / max_met_capacity, 0.0, 1.0)
    
    # STEP 2: Base RPE from relative intensity
    # Non-linear mapping: children perceive moderate intensities as 
    # disproportionately harder (Utter et al., 2002)
    if relative_intensity <= 0.3:
        # Light effort
        base_rpe = relative_intensity * 10.0  # Range: 0-3
    elif relative_intensity <= 0.6:
        # Moderate effort (steeper slope)
        base_rpe = 3.0 + (relative_intensity - 0.3) * 11.0  # Range: 3-6.3
    elif relative_intensity <= 0.85:
        # Hard effort
        base_rpe = 6.3 + (relative_intensity - 0.6) * 10.8  # Range: 6.3-9.0
    else:
        # Very hard/maximal
        base_rpe = 9.0 + (relative_intensity - 0.85) * 6.7  # Range: 9.0-10.0
    
    # STEP 3: Fitness adaptation effect
    # Max 20% reduction
    fitness_reduction = fitness_factor * 0.20
    adjusted_base = base_rpe * (1.0 - fitness_reduction)
    
    # STEP 4: Thermal strain effect
    # Children have higher threshold and delayed perception
    if t_core > thermal_threshold:
        # More gradual RPE increase reflecting delayed perception
        heat_penalty = (t_core - thermal_threshold) * 1.2
    else:
        heat_penalty = 0.0
    
    # Physical RPE (without psychological factors)
    rpe_physical = np.clip(adjusted_base + heat_penalty, 0.0, 10.0)
    
    # STEP 5: Motivational/affective modulation
    # Children show GREATER emotional influence (±25%)
    motivation_modifier = (mf_score - 0.5) * 2.0  # Map [0,1] to [-1,1]
    motivation_effect = motivation_modifier * (10.0 - rpe_physical) * 0.25
    
    rpe_total = np.clip(rpe_physical + motivation_effect, 0.0, 10.0)
    
    return rpe_physical, rpe_total


# =============================================================================
#                    CORE SIMULATION RUNNERS (WORKERS)
# =============================================================================

def calculate_indices_jos3_adult(interp_data, lat, lon, met_value, clo_value,
                                 participant_params, training_factor, acclimatization_factor):
    """
    Runs the core JOS3 simulation for a single virtual adult participant.
    
    This function takes one set of participant parameters and simulates
    their physiological response (core temp, sweat loss) and
    psychobiological response (RPE) over the event duration.
    
    Parameters:
    -----------
    interp_data : list of dicts
        Interpolated environmental data for each time step.
    lat, lon : float
        Location coordinates.
    met_value : float
        Base MET value of the activity.
    clo_value : float
        Base clothing insulation value (clo).
    participant_params : tuple
        A tuple of parameters from `simulate_runner`.
    training_factor : float
        Simulation-wide training factor.
    acclimatization_factor : float
        Simulation-wide acclimatization factor.
        
    Returns:
    --------
    list of dicts :
        A list of results, one dict per time step, containing
        T_rect, RPE, water loss, etc.
    """
    (height, weight, temp_var, rh_var, met_var, mf_score, sweat_factor,
     thirst_threshold, gender, runner_age) = participant_params

    # Environment setup (with individual variations)
    times = [entry["time"] for entry in interp_data]
    temps = [entry["temp"] + temp_var for entry in interp_data]
    wind_10m = [entry["wind"] for entry in interp_data]
    wind_1_5m = [wind_speed_at_height(w, 10, 1.5) for w in wind_10m] # Wind at 1.5m
    rhs = [np.clip(entry["rh"] + rh_var, 10, 95) for entry in interp_data]
    clouds = [entry["clouds"] for entry in interp_data]
    pressures = [entry["pressure"] for entry in interp_data]
    
    # Calculate detailed environmental indices
    aqi = get_air_quality(lat, lon)
    radiances = [calculate_solar_radiance(lat, lon, str(t), c, aqi) for t, c in zip(times, clouds)]
    ghi = [rad['ghi'] for rad in radiances]
    solar_elevations = [rad['solar_elevation'] for rad in radiances]
    globe_temps = [calculate_globe_temperature(t, g, w, se, p, c, aqi) for t, g, w, se, p, c in zip(temps, ghi, wind_1_5m, solar_elevations, pressures, clouds)]
    mrts = [calculate_mrt(gt, t, w, g, se) for gt, t, w, g, se in zip(globe_temps, temps, wind_1_5m, ghi, solar_elevations)]

    # JOS3 model setup
    fat_percentage = 25 if gender == "female" else 15
    jos3_model = JOS3(height=height, weight=weight, age=runner_age, fat=fat_percentage, sex=gender)
    jos3_model.t_core[:] = 37.0 # Set initial core temp
    time_steps_minutes = [(times[i+1] - times[i]).total_seconds() / 60.0 for i in range(len(times)-1)]
    time_steps_minutes.insert(0, 0)

    results = []
    cumulative_water_loss = 0
    runner_stopped = False
    can_drink_again = True
    
    current_met = met_value + met_var # Participant's specific MET

    for i in range(len(times)):
        if runner_stopped and i > 0:
            # If runner stopped, carry forward the last valid result
            results.append({**results[-1], 'time': times[i].strftime('%Y-%m-%d %H:%M'), 'stopped': True})
            continue

        # Liveability Check (Vanos et al., 2023)
        m_max_threshold = get_liveability_threshold(temps[i], rhs[i], runner_age)
        is_unliveable = current_met > m_max_threshold

        # Simulation step
        jos3_model.par = current_met
        jos3_model.tdb = temps[i]
        jos3_model.tr = mrts[i]
        jos3_model.rh = rhs[i]
        jos3_model.v = max(0.1, wind_1_5m[i])
        jos3_model.clo = clo_value
        if i > 0:
            jos3_model.simulate(times=int(round(time_steps_minutes[i])), dtime=60)
        #t_rect = jos3_model.t_core.mean() # JOS3's average core temp
        t_rect = jos3_model.t_core.mean() + 0.5 # JOS3's average core temp
        
        # --- Water loss directly from JOS3 model output (rev06 update) ---
        # Prefer the JOS-3 'weight_loss_by_evap_and_res' result (g/s) if available.
        # This value already includes evaporative (sweating) and respiratory water loss
        # and is computed by the JOS-3 model. We convert to ml/min (≈ g/min) and apply
        # the individual sweat_factor.
        results_jos3 = jos3_model.dict_results()
        if 'weight_loss_by_evap_and_res' in results_jos3:
            # value is in g/sec (whole-body)
            water_loss_rate_g_per_s = np.mean(results_jos3['weight_loss_by_evap_and_res'])
        else:
            # Fallback approximation (backward-compatible): fraction of metabolic heat
            metabolic_heat_flux = jos3_model.par * 58.2  # W/m^2 (approx)
            evap_fraction = 0.6  # assume ~60% lost as evaporation in hot exercise
            bsa = np.mean(jos3_model.bsa)
            # Convert heat flux -> g/s using latent heat of vaporization (2418 J/g)
            water_loss_rate_g_per_s = (metabolic_heat_flux * bsa * evap_fraction) / 2418.0

        # Convert to ml/min and apply individual factor (1 g ≈ 1 ml)
        sweat_rate = water_loss_rate_g_per_s * 60.0 * sweat_factor  # ml/min

        # --- Cumulative water loss tracking ---
        
        # +++ START BUG FIX +++
        # Calculate water loss for this time step
        water_loss = sweat_rate * time_steps_minutes[i] if i > 0 else 0
        cumulative_water_loss += water_loss
        
        # Calculate percentage loss to check against the threshold
        water_loss_percentage = (cumulative_water_loss / 1000) / weight * 100
        
        # Define is_thirsty
        is_thirsty = water_loss_percentage >= thirst_threshold
        # +++ END BUG FIX +++

        if is_thirsty and can_drink_again:
           intake_amount = np.random.uniform(120, 180) # Drink 120-180ml
           cumulative_water_loss = max(0, cumulative_water_loss - intake_amount)
           can_drink_again = False # Cooldown period for drinking
        
        # +++ START LOGIC FIX +++
        # Reset drinking capability *after* thirst is no longer met
        if not is_thirsty:
            can_drink_again = True
        # +++ END LOGIC FIX +++

        # Index calculation (UTCI & WBGT)
        utci_val = utci(tdb=temps[i], tr=mrts[i], v=wind_10m[i], rh=rhs[i]).utci
        with_solar_load_flag = bool(ghi[i] > 0 and solar_elevations[i] > 0)
        wbgt_args = {
            "twb": wet_bulb_tmp(tdb=temps[i], rh=rhs[i]),
            "tg": globe_temps[i],
            "with_solar_load": with_solar_load_flag,
            "round_output": True
        }
        if with_solar_load_flag:
            wbgt_args["tdb"] = temps[i]
        wbgt_result = wbgt(**wbgt_args)
        wbgt_val = float(wbgt_result.wbgt)

        # RPE calculation (using improved model)
        rpe_physical, rpe_total = calculate_adult_rpe_improved(
            current_met=current_met,
            t_rect=t_rect,
            training_factor=training_factor,
            acclimatization_factor=acclimatization_factor,
            mf_score=mf_score
        )
        
        if rpe_total >= 19.5:
            runner_stopped = True
            
        # First aid visit criteria
        ehbo_visit = (t_rect >= 40.5) or (water_loss_percentage >= 2.0) or (rpe_total >= 17)

        results.append({
            "time": times[i].strftime('%Y-%m-%d %H:%M'), "utci": utci_val, "wbgt": wbgt_val,
            "t_rect": t_rect, "water": cumulative_water_loss, "mrt": mrts[i],
            "rpe_physical": rpe_physical, "rpe_total": rpe_total, "stopped": runner_stopped,
            "ehbo_visit": ehbo_visit,
            "is_unliveable": is_unliveable
        })
    return results

def run_pediatric_simulation(interp_data, lat, lon, met_value, clo_value,
                             participant_params, age_group="11-20", fitness_factor=0.5):
    """
    Runs the core JOS3 simulation for a single virtual pediatric participant.
    
    This function takes one set of participant parameters and simulates
    their physiological (core temp, sweat) and psychobiological (RPE)
    response over the activity duration.
    
    Parameters:
    -----------
    interp_data : list of dicts
        Interpolated environmental data for each time step.
    lat, lon : float
        Location coordinates.
    met_value : float
        Base MET value of the activity.
    clo_value : float
        Base clothing insulation value (clo).
    participant_params : tuple
        A tuple of parameters from `simulate_child_participant`.
    age_group : str
        "0-10" or "11-20".
    fitness_factor : float
        Simulation-wide fitness factor.
        
    Returns:
    --------
    list of dicts :
        A list of results, one dict per time step, containing
        T_core, RPE, water loss, etc.
    """
    height, weight, temp_var, rh_var, met_var, mf_score, sweat_factor, thirst_threshold = participant_params

    # Environment setup
    if age_group == "0-10":
        age = 7
        fat_percentage = 18
        gender = 'male' # Assume male for simplicity, can be randomized
    else:
        age = 15
        gender = np.random.choice(["male", "female"])
        fat_percentage = 22 if gender == 'female' else 15

    times = [entry["time"] for entry in interp_data]
    temps = [entry["temp"] + temp_var for entry in interp_data]
    wind_10m = [entry["wind"] for entry in interp_data]
    wind_1_5m = [wind_speed_at_height(w, 10, 1.0) for w in wind_10m] # Wind at 1.0m (shorter)
    rhs = [np.clip(entry["rh"] + rh_var, 10, 95) for entry in interp_data]
    clouds = [entry["clouds"] for entry in interp_data]
    pressures = [entry["pressure"] for entry in interp_data]
    
    # Calculate detailed environmental indices
    aqi = get_air_quality(lat, lon)
    radiances = [calculate_solar_radiance(lat, lon, str(t), c, aqi) for t, c in zip(times, clouds)]
    ghi = [rad['ghi'] for rad in radiances]
    solar_elevations = [rad['solar_elevation'] for rad in radiances]
    globe_temps = [calculate_globe_temperature(t, g, w, se, p, c, aqi) for t, g, w, se, p, c in zip(temps, ghi, wind_1_5m, solar_elevations, pressures, clouds)]
    mrts = [calculate_mrt(gt, t, w, g, se) for gt, t, w, g, se in zip(globe_temps, temps, wind_1_5m, ghi, solar_elevations)]

    # JOS3 model setup
    jos3_model = JOS3(height=height, weight=weight, age=age, fat=fat_percentage, sex=gender)
    jos3_model.t_core[:] = 37.0

    time_steps_minutes = [(times[i+1] - times[i]).total_seconds() / 60.0 for i in range(len(times)-1)]
    time_steps_minutes.insert(0, 0)
    results = []
    cumulative_water_loss = 0
    participant_stopped = False
    can_drink_again = True
    
    current_met = met_value + met_var

    for i in range(len(times)):
        if participant_stopped and i > 0:
            results.append({**results[-1], 'time': times[i].strftime('%Y-%m-%d %H:%M'), 'stopped': True})
            continue

        # Simulation step
        jos3_model.par = current_met
        jos3_model.tdb = temps[i]
        jos3_model.tr = mrts[i]
        jos3_model.rh = rhs[i]
        jos3_model.v = max(0.1, wind_1_5m[i])
        jos3_model.clo = clo_value
        if i > 0:
            jos3_model.simulate(times=int(round(time_steps_minutes[i])), dtime=60)
        t_core_avg = jos3_model.t_core.mean()

        # Water balance (blunted thirst / "voluntary dehydration")
        sweat_rate_ml_per_min = sweat_factor * (jos3_model.par * 58.2 * np.mean(jos3_model.bsa)) / 2418 * 1000 / 60
        water_loss_per_part = sweat_rate_ml_per_min * time_steps_minutes[i] if i > 0 else 0
        cumulative_water_loss += water_loss_per_part
        water_loss_percentage = (cumulative_water_loss / 1000) / weight * 100
        
        # Drinking strategy
        is_thirsty = water_loss_percentage >= thirst_threshold
        if is_thirsty and can_drink_again:
            intake_amount = np.random.uniform(100, 150) # Drink 100-150ml
            cumulative_water_loss = max(0, cumulative_water_loss - intake_amount)
            can_drink_again = False
        if not is_thirsty:
            can_drink_again = True

        # Index calculation (UTCI & WBGT)
        utci_val = utci(tdb=temps[i], tr=mrts[i], v=wind_10m[i], rh=rhs[i]).utci
        with_solar_load_flag = bool(ghi[i] > 0 and solar_elevations[i] > 0)
        wbgt_args = {
            "twb": wet_bulb_tmp(tdb=temps[i], rh=rhs[i]),
            "tg": globe_temps[i],
            "with_solar_load": with_solar_load_flag,
            "round_output": True
        }
        if with_solar_load_flag:
            wbgt_args["tdb"] = temps[i]
        wbgt_result = wbgt(**wbgt_args)
        wbgt_val = float(wbgt_result.wbgt)

        # RPE calculation (using improved pediatric model)
        rpe_physical, rpe_total = calculate_pediatric_rpe_improved(
            current_met=current_met,
            t_core=t_core_avg,
            fitness_factor=fitness_factor,
            mf_score=mf_score,
            age_group=age_group
        )

        if rpe_total >= 9.5:
            participant_stopped = True
            
        # First aid visit criteria
        first_aid_visit = (t_core_avg >= 38.8) or (water_loss_percentage >= 3.0) or (rpe_total >= 8.5)

        results.append({
            "time": times[i].strftime('%Y-%m-%d %H:%M'), "utci": utci_val, "wbgt": wbgt_val,
            "t_core": t_core_avg, "water_loss_ml": cumulative_water_loss, "mrt": mrts[i],
            "rpe_physical": rpe_physical, "rpe_total": rpe_total, "stopped": participant_stopped,
            "first_aid_visit": first_aid_visit
        })
    return results

def worker_monte_carlo_adult(args):
    """Worker for running a single adult Monte Carlo simulation in parallel."""
    interp_data, lat, lon, met_value, clo_value, params, training, acclimatization = args
    return calculate_indices_jos3_adult(
        interp_data, lat, lon, met_value, clo_value, params, training, acclimatization
    )


def worker_monte_carlo_pediatric(args):
    """Worker for running a single pediatric Monte Carlo simulation in parallel."""
    interp_data, lat, lon, met_value, clo_value, params, age_group, fitness_factor = args
    return run_pediatric_simulation(
        interp_data, lat, lon, met_value, clo_value, params, age_group, fitness_factor
    )


# =============================================================================
#                    MONTE CARLO MANAGERS
# =============================================================================
def _calculate_threshold_stats(temp_sims, n_simulations):
    """
    Helper function to calculate statistics for core temperature thresholds.
    Calculates the mean percentage of the population exceeding each
    threshold at each time step, with 95% confidence intervals.
    """
    thresholds = [38.0, 38.5, 39.0, 39.5, 40.0, 40.5, 41.0]
    stats = {}

    for t in thresholds:
        # Calculate percentage of population exceeding threshold
        p = np.mean(temp_sims > t, axis=0)

        # Calculate 95% confidence interval for the proportion
        se = np.sqrt(p * (1 - p) / n_simulations) if n_simulations > 0 else 0
        ci_margin = 1.96 * se

        stats[f"{t:.1f}"] = {
            'mean': p * 100,
            'ci_lower': np.maximum(0, p - ci_margin) * 100,
            'ci_upper': np.minimum(1, p + ci_margin) * 100,
        }
    return stats


def get_age_group(age):
    """Categorizes a specific age into a predefined group string."""
    if 18 <= age <= 29:
        return "18–29"
    elif 30 <= age <= 39:
        return "30–39"
    elif 40 <= age <= 49:
        return "40–49"
    elif 50 <= age <= 59:
        return "50–59"
    else:
        return "60–65"


def run_monte_carlo_adult(interp_data, lat, lon, met_value, clo_value,
                          n_simulations, age_configuration,
                          training_factor, acclimatization_factor, use_parallel=True):
    """
    Manages the entire adult Monte Carlo simulation process.
    
    This function generates the participant profiles, distributes the
    simulation tasks (in parallel), aggregates the results,
    and calculates final population statistics.
    
    Parameters:
    -----------
    (See `calculate_indices_jos3_adult` for most)
    n_simulations : int
        Number of participants to simulate.
    age_configuration : str or tuple
        "standard" for a normal distribution, or (min_age, max_age)
        for a specific group.
    use_parallel : bool
        Whether to use multiprocessing.
        
    Returns:
    --------
    tuple : (all_results, stats, results_df)
        all_results : Raw list of results from all simulations.
        stats : Aggregated statistics (mean, 95th percentile, etc.).
        results_df : A pandas DataFrame for Excel export.
    """
    simulations_params_base = simulate_runner(
        n_simulations, met_value, training_factor, acclimatization_factor
    )

    # Ensure we only use the number of successfully generated profiles
    n_simulations = len(simulations_params_base)
    if n_simulations == 0:
        print(f"{Fore.RED}Failed to generate any valid participant profiles. Aborting simulation.{Style.RESET_ALL}")
        return None, None, None

    # Lists to store participant demographics and worker arguments
    participant_demographics = []
    worker_args = []

    for params in simulations_params_base:
        # Assign age based on user configuration
        if age_configuration == "standard":
            age = int(np.clip(np.random.normal(loc=35, scale=10), 18, 65))
        else:
            min_age, max_age = age_configuration
            age = np.random.randint(min_age, max_age + 1)

        # Extract gender from params (it's the 9th element, index 8)
        gender = params[8]

        # Append age to the params tuple for the worker
        full_params = params + (age,)
        worker_args.append((interp_data, lat, lon, met_value, clo_value, full_params,
                            training_factor, acclimatization_factor))

        # Store demographics for later analysis
        participant_demographics.append({
            'age': age,
            'age_group': get_age_group(age),
            'gender': gender
        })

    # Run simulations in parallel
    if use_parallel:
        with Pool(multiprocessing.cpu_count()) as pool:
            all_results = list(tqdm(pool.imap(worker_monte_carlo_adult, worker_args), total=len(worker_args), desc="Monte Carlo Adult Sims", unit="sim"))
    else:
        all_results = [worker_monte_carlo_adult(args) for args in tqdm(worker_args, desc="Monte Carlo Adult Sims", unit="sim")]

    # Process results into NumPy arrays for fast statistics
    t_rect_sims = np.array([[r["t_rect"] for r in res] for res in all_results])
    water_sims = np.array([[r["water"] for r in res] for res in all_results])
    rpe_sims = np.array([[r["rpe_total"] for r in res] for res in all_results])
    stopped_sims = np.array([[r["stopped"] for r in res] for res in all_results])
    ehbo_sims = np.array([[r["ehbo_visit"] for r in res] for res in all_results])
    unliveable_sims = np.array([[r["is_unliveable"] for r in res] for res in all_results])

    # Calculate time-series statistics
    stats = {
        'mean_t_rect': np.mean(t_rect_sims, axis=0),
        'lower_t_rect': np.percentile(t_rect_sims, 5, axis=0),
        'upper_t_rect': np.percentile(t_rect_sims, 95, axis=0),
        'mean_water': np.mean(water_sims, axis=0),
        'lower_water': np.percentile(water_sims, 5, axis=0),
        'upper_water': np.percentile(water_sims, 95, axis=0),
        'mean_rpe': np.mean(rpe_sims, axis=0),
        'lower_rpe': np.percentile(rpe_sims, 5, axis=0),
        'upper_rpe': np.percentile(rpe_sims, 95, axis=0),
        'percent_stopped': np.mean(stopped_sims, axis=0) * 100,
        'percent_ehbo': np.mean(ehbo_sims, axis=0) * 100,
        'percent_unliveable': np.mean(unliveable_sims, axis=0) * 100,
        'temp_threshold_stats': _calculate_threshold_stats(t_rect_sims, n_simulations)
    }

    # NOTE: Create a detailed DataFrame for the Excel export
    detailed_export_data = []
    for i, sim_result in enumerate(all_results):
        # Base input parameters
        base_params = simulations_params_base[i]
        demographics = participant_demographics[i]

        # Output results (maximum values)
        max_t_rect = max([r["t_rect"] for r in sim_result])
        max_rpe = max([r["rpe_total"] for r in sim_result])
        if base_params[1] > 0: # weight
            max_water_loss_perc = max([r["water"] / 1000 / base_params[1] * 100 for r in sim_result])
        else:
            max_water_loss_perc = 0
        
        participant_data = {
            'participant_id': i + 1,
            'age': demographics['age'],
            'gender': demographics['gender'],
            'age_group': demographics['age_group'],
            'height_m': round(base_params[0], 2),
            'weight_kg': round(base_params[1], 1),
            'temp_variation_C': round(base_params[2], 2),
            'rh_variation_perc': round(base_params[3], 1),
            'met_variation': round(base_params[4], 2),
            'mf_score': round(base_params[5], 2),
            'sweat_factor': round(base_params[6], 2),
            'thirst_threshold_perc': round(base_params[7], 2),
            'max_t_rect': round(max_t_rect, 4),
            'max_rpe': round(max_rpe, 2),
            'max_water_loss_perc': round(max_water_loss_perc, 2)
        }
        detailed_export_data.append(participant_data)

    results_df = pd.DataFrame(detailed_export_data)

    return all_results, stats, results_df


def run_monte_carlo_pediatric(interp_data, lat, lon, met_value, clo_value,
                              n_simulations=200, age_group="11-20", fitness_factor=0.5, use_parallel=True):
    """
    Manages the entire pediatric Monte Carlo simulation process.
    
    Generates profiles, distributes tasks, aggregates results,
    and calculates population statistics for children.
    
    Parameters:
    -----------
    (See `run_pediatric_simulation` for most)
    n_simulations : int
        Number of participants to simulate.
    use_parallel : bool
        Whether to use multiprocessing.
        
    Returns:
    --------
    tuple : (all_results, stats)
        all_results : Raw list of results from all simulations.
        stats : Aggregated statistics (mean, 95th percentile, etc.).
    """
    participant_params_list = simulate_child_participant(n_simulations, met_value, age_group, fitness_factor)

    # Ensure we only use the number of successfully generated profiles
    n_simulations = len(participant_params_list)
    if n_simulations == 0:
        print(f"{Fore.RED}Failed to generate any valid participant profiles. Aborting simulation.{Style.RESET_ALL}")
        return None, None

    worker_args = [(interp_data, lat, lon, met_value, clo_value, params, age_group, fitness_factor) for params in participant_params_list]

    if use_parallel:
        with Pool(multiprocessing.cpu_count()) as pool:
            all_results = list(tqdm(pool.imap(worker_monte_carlo_pediatric, worker_args), total=len(worker_args), desc="Monte Carlo Pediatric Sims", unit="sim"))
    else:
        all_results = [worker_monte_carlo_pediatric(args) for args in tqdm(worker_args, desc="Monte Carlo Pediatric Sims", unit="sim")]

    # Process results
    t_core_sims = np.array([[r["t_core"] for r in res] for res in all_results])
    water_sims = np.array([[r["water_loss_ml"] for r in res] for res in all_results])
    rpe_total_sims = np.array([[r["rpe_total"] for r in res] for res in all_results])
    stopped_sims = np.array([[r["stopped"] for r in res] for res in all_results])
    first_aid_sims = np.array([[r["first_aid_visit"] for r in res] for res in all_results])

    stats = {
        'mean_t_core': np.mean(t_core_sims, axis=0),
        'lower_t_core': np.percentile(t_core_sims, 5, axis=0),
        'upper_t_core': np.percentile(t_core_sims, 95, axis=0),
        'mean_water': np.mean(water_sims, axis=0),
        'lower_water': np.percentile(water_sims, 5, axis=0),
        'upper_water': np.percentile(water_sims, 95, axis=0),
        'mean_rpe': np.mean(rpe_total_sims, axis=0),
        'lower_rpe': np.percentile(rpe_total_sims, 5, axis=0),
        'upper_rpe': np.percentile(rpe_total_sims, 95, axis=0),
        'percent_stopped': np.mean(stopped_sims, axis=0) * 100,
        'percent_first_aid': np.mean(first_aid_sims, axis=0) * 100,
        'temp_threshold_stats': _calculate_threshold_stats(t_core_sims, n_simulations)
    }

    return all_results, stats


# =============================================================================
#                    RISK & PLOTTING FUNCTIONS
# =============================================================================

def calculate_adult_risk_classification(utci_val, wbgt_val, t_rect, rpe_total):
    """
    Calculates a composite risk classification for adults based on
    environmental (UTCI, WBGT) and physiological (T_rect, RPE) indices.
    The final risk is the *maximum* risk found across all indices.
    
    Returns:
    --------
    dict : {"risk_color", "detailed_risk"}
    """
    scores = {
        'utci': 0 if utci_val <= 26 else 1 if utci_val <= 32 else 2 if utci_val <= 38 else 3 if utci_val <= 46 else 4,
        'wbgt': 0 if wbgt_val < 25 else 1 if wbgt_val < 28 else 2 if wbgt_val < 31 else 3 if wbgt_val < 33 else 4,
        't_rect': 0 if t_rect < 38 else 1 if t_rect < 39 else 2 if t_rect < 39.5 else 3 if t_rect < 40 else 4,
        'rpe': 0 if rpe_total < 12 else 1 if rpe_total < 15 else 2 if rpe_total < 17 else 3 if rpe_total < 19 else 4
    }
    total_score = max(scores.values())
    risk_levels = {
        0: ("No risk", Fore.WHITE), 
        1: ("Low risk", Fore.GREEN), 
        2: ("Moderate risk", Fore.YELLOW), 
        3: ("High risk", Fore.MAGENTA), 
        4: ("Extreme risk", Fore.RED)
    }
    risk_text, risk_color = risk_levels[total_score]

    return {"risk_color": risk_color, "detailed_risk": f"{risk_text} (U:{scores['utci']}/W:{scores['wbgt']}/T:{scores['t_rect']}/RPE:{scores['rpe']})"}


def calculate_pediatric_risk_classification(utci_val, wbgt_val, t_core, rpe_total):
    """
    Calculates a composite risk classification for children.
    Uses more conservative thresholds for WBGT and T_core.
    The final risk is the *maximum* risk found across all indices.
    
    Returns:
    --------
    dict : {"risk_color", "detailed_risk"}
    """
    scores = {
        'utci': 0 if utci_val <= 26 else 1 if utci_val <= 32 else 2 if utci_val <= 38 else 3 if utci_val <= 46 else 4,
        'wbgt': 0 if wbgt_val < 23 else 1 if wbgt_val < 26 else 2 if wbgt_val < 29 else 3 if wbgt_val < 31 else 4, # More conservative
        't_core': 0 if t_core < 38.2 else 1 if t_core < 38.8 else 2 if t_core < 39.2 else 3 if t_core < 39.8 else 4,
        'rpe': 0 if rpe_total < 4 else 1 if rpe_total < 6 else 2 if rpe_total < 8 else 3 if rpe_total < 9 else 4
    }
    total_score = max(scores.values())
    risk_levels = {
        0: ("No risk", Fore.WHITE), 
        1: ("Low risk", Fore.GREEN), 
        2: ("Moderate risk", Fore.YELLOW), 
        3: ("High risk", Fore.MAGENTA), 
        4: ("Extreme risk", Fore.RED)
    }
    risk_text, risk_color = risk_levels[total_score]

    return {"risk_color": risk_color, "detailed_risk": f"{risk_text} (U:{scores['utci']}/W:{scores['wbgt']}/T:{scores['t_core']}/RPE:{scores['rpe']})"}


def plot_adult_results(results, stats, city_name, start_time, duration_hours):
    """Generates and displays a 4-panel plot for the adult simulation results."""
    times_str = [r["time"] for r in results[0]]
    times_dt = [pd.to_datetime(t) for t in times_str]

    fig, axs = plt.subplots(2, 2, figsize=(20, 14), gridspec_kw={'hspace': 0.4, 'wspace': 0.3})
    main_title = f"Adult Thermal Simulation for {city_name} on {pd.to_datetime(start_time).date()}"
    fig.suptitle(main_title, fontsize=18, weight='bold')

    # --- Core Temperature Plot ---
    ax1 = axs[0, 0]
    ax1.plot(times_dt, stats['mean_t_rect'], 'b-', label='Mean $T_{rect}$')
    ax1.fill_between(times_dt, stats['lower_t_rect'], stats['upper_t_rect'], color='blue', alpha=0.2, label='5th-95th Percentile')
    ax1.axhline(y=39.0, color='gold', linestyle='--', label='Heat Stress (39°C)')
    ax1.axhline(y=40.0, color='darkorange', linestyle='--', label='Serious Risk (40°C)')
    ax1.axhline(y=42.0, color='red', linestyle='--', label='Life-threatening (42°C)')
    ax1.axhline(y=43.0, color='black', linestyle='-', linewidth=2, label='Lethal Limit (43°C, Vanos et al. 2023)')
    ax1.set_title("Core Body Temperature ($T_{rect}$)", fontsize=14)
    ax1.set_ylabel("$T_{rect}$ (°C)", fontsize=12)
    ax1.legend()

    # --- RPE Plot ---
    ax2 = axs[0, 1]
    ax2.plot(times_dt, stats['mean_rpe'], 'r-', label='Mean RPE')
    ax2.fill_between(times_dt, stats['lower_rpe'], stats['upper_rpe'], color='red', alpha=0.2, label='5th-95th Percentile')
    ax2.axhline(y=17, color='purple', linestyle=':', label='Exhaustion Threshold (RPE 17)')
    ax2.axhline(y=19.5, color='black', linestyle='--', label='Stop Threshold (RPE 19.5)')
    ax2.set_title("Rate of Perceived Exertion (Borg 6-20 Scale)", fontsize=14)
    ax2.set_ylabel("RPE (6-20)", fontsize=12)
    ax2.set_ylim(6, 20.5)
    ax2.legend()

    # --- Environmental Indices ---
    ax3 = axs[1, 0]
    utci_vals = [r["utci"] for r in results[0]]
    wbgt_vals = [r["wbgt"] for r in results[0]]
    ax3.plot(times_dt, utci_vals, color='purple', label='UTCI (°C)')
    ax3.set_ylabel("UTCI (°C)", color='purple', fontsize=12)
    ax3.legend(loc='upper left')
    ax4 = ax3.twinx() # Create a second y-axis
    ax4.plot(times_dt, wbgt_vals, color='green', label='WBGT (°C)')
    ax4.set_ylabel("WBGT (°C)", color='green', fontsize=12)
    ax4.legend(loc='upper right')
    ax3.set_title("Environmental Thermal Indices", fontsize=14)

    # --- Risk & Liveability Percentage Plot ---
    ax5 = axs[1, 1]
    ax5.plot(times_dt, stats['percent_stopped'], color='black', linestyle='--', label='% Stopped (RPE > 19.5)')
    ax5.plot(times_dt, stats['percent_ehbo'], color='magenta', linestyle='--', label='% First Aid Visit')
    ax5.plot(times_dt, stats['percent_unliveable'], color='darkviolet', linewidth=2.5, label='% in Unliveable Condition (Vanos et al.)')
    ax5.fill_between(times_dt, 0, stats['percent_unliveable'], color='darkviolet', alpha=0.2)
    ax5.set_title("Percentage of Participants at Risk", fontsize=14)
    ax5.set_ylabel("Participants (%)", fontsize=12)
    ax5.set_ylim(0, 101)
    ax5.legend()

    # Format all axes
    for ax in axs.flat:
        ax.set_xlabel("Time", fontsize=12)
        ax.grid(True, linestyle='--', alpha=0.6)
        ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))
        ax.tick_params(axis='x', rotation=45)

    plt.tight_layout(rect=[0, 0, 1, 0.95])
    plt.show(block=False)


def plot_pediatric_results(results, stats, city_name, start_time, duration_hours):
    """Generates and displays a 4-panel plot for the pediatric simulation results."""
    times_str = [r["time"] for r in results[0]]
    times_dt = [pd.to_datetime(t) for t in times_str]

    fig, axs = plt.subplots(2, 2, figsize=(20, 14), gridspec_kw={'hspace': 0.4, 'wspace': 0.3})
    main_title = f"Pediatric Thermal Simulation for {city_name} on {pd.to_datetime(start_time).date()}"
    fig.suptitle(main_title, fontsize=18, weight='bold')

    # --- Core Temperature Plot ---
    ax1 = axs[0, 0]
    ax1.plot(times_dt, stats['mean_t_core'], 'b-', label='Mean $T_{core}$')
    ax1.fill_between(times_dt, stats['lower_t_core'], stats['upper_t_core'], color='blue', alpha=0.2, label='5th-95th Percentile')
    ax1.axhline(y=38.5, color='gold', linestyle='--', label='Moderate Stress (38.5°C)')
    ax1.axhline(y=39.2, color='darkorange', linestyle='--', label='High Risk (39.2°C)')
    ax1.axhline(y=40.0, color='red', linestyle='--', label='Extreme Risk (40.0°C)')
    ax1.set_title("Core Body Temperature ($T_{core}$)", fontsize=14)
    ax1.set_ylabel("$T_{core}$ (°C)", fontsize=12)
    ax1.legend()

    # --- RPE Plot ---
    ax2 = axs[0, 1]
    ax2.plot(times_dt, stats['mean_rpe'], 'r-', label='Mean RPE')
    ax2.fill_between(times_dt, stats['lower_rpe'], stats['upper_rpe'], color='red', alpha=0.2, label='5th-95th Percentile')
    ax2.axhline(y=8, color='purple', linestyle=':', label='High Exertion Threshold (RPE 8)')
    ax2.axhline(y=9.5, color='black', linestyle='--', label='Stop Threshold (RPE 9.5)')
    ax2.set_title("Perceived Exertion (OMNI 0-10 Scale)", fontsize=14)
    ax2.set_ylabel("RPE (0-10)", fontsize=12)
    ax2.set_ylim(0, 10.5)
    ax2.legend()

    # --- Environmental Indices ---
    ax3 = axs[1, 0]
    utci_vals = [r["utci"] for r in results[0]]
    wbgt_vals = [r["wbgt"] for r in results[0]]
    ax3.plot(times_dt, utci_vals, color='purple', label='UTCI (°C)')
    ax3.set_ylabel("UTCI (°C)", color='purple', fontsize=12)
    ax3.tick_params(axis='y', labelcolor='purple')
    ax3.legend(loc='upper left')
    ax4 = ax3.twinx()
    ax4.plot(times_dt, wbgt_vals, color='green', label='WBGT (°C)')
    ax4.set_ylabel("WBGT (°C)", color='green', fontsize=12)
    ax4.tick_params(axis='y', labelcolor='green')
    ax4.legend(loc='upper right')
    ax3.set_title("Environmental Thermal Indices", fontsize=14)

    # --- Risk Percentage ---
    ax5 = axs[1, 1]
    ax5.plot(times_dt, stats['percent_stopped'], color='black', label='% Stopped due to Exertion')
    ax5.plot(times_dt, stats['percent_first_aid'], color='magenta', linestyle='--', label='% Requiring First Aid')
    ax5.set_title("Percentage of Participants at Risk", fontsize=14)
    ax5.set_ylabel("Participants (%)", fontsize=12)
    ax5.set_ylim(0, 101)
    ax5.legend()

    # Format all axes
    for ax in axs.flat:
        ax.set_xlabel("Time", fontsize=12)
        ax.grid(True, linestyle='--', alpha=0.6)
        ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))
        ax.tick_params(axis='x', rotation=45)

    plt.tight_layout(rect=[0, 0, 1, 0.95])
    plt.show(block=False)


def plot_adult_boxplots(results_df):
    """Generates boxplots for adult simulation results by age group and gender."""
    if results_df is None or results_df.empty:
        print("No data available for boxplots.")
        return

    sns.set(style="whitegrid")

    # Define variables to plot
    variables = [
        ('max_t_rect', 'Maximum Core Temperature (°C)', [37, 42]),
        ('max_rpe', 'Maximum Perceived Exertion (RPE)', [6, 20]),
        ('max_water_loss_perc', 'Maximum Water Loss (% body weight)', [0, 5])
    ]

    # Create subplots
    fig, axes = plt.subplots(3, 1, figsize=(14, 18))
    fig.suptitle("Distribution of Max Values by Age Group and Gender", fontsize=16)


    for i, (var, title, ylim) in enumerate(variables):
        ax = axes[i]
        order = sorted(results_df['age_group'].unique())
        sns.boxplot(
            data=results_df,
            x='age_group',
            y=var,
            hue='gender',
            ax=ax,
            palette={"male": "skyblue", "female": "lightpink"},
            showmeans=True,
            meanprops={"marker":"o", "markerfacecolor":"white", "markeredgecolor":"black"},
            order = order
        )
        ax.set_title(title, fontsize=14)
        ax.set_xlabel("Age Group", fontsize=12)
        ax.set_ylabel(title.split('(')[0].strip(), fontsize=12) # Use shorter label
        ax.set_ylim(ylim)
        ax.legend(title="Gender", loc='upper right')
        ax.grid(True, linestyle='--', alpha=0.6)

        # Add data points with some jitter for detail
        sns.stripplot(
            data=results_df,
            x='age_group',
            y=var,
            hue='gender',
            ax=ax,
            dodge=True,
            jitter=True,
            alpha=0.4,
            palette={"male": "blue", "female": "red"},
            legend=False,
            order = order
        )

    plt.tight_layout(rect=[0, 0, 1, 0.95])
    plt.show(block=False)


# =============================================================================
#         *** NEW: MET THRESHOLD ANALYSIS AND PLOTTING FUNCTIONS ***
# =============================================================================

def get_representative_participant(age, gender):
    """Creates a standardized JOS-3 participant for a given age and gender."""
    if gender == 'male':
        height = 1.80
        weight = 78
        fat = 15
    else: # female
        height = 1.67
        weight = 65
        fat = 25
    return {'height': height, 'weight': weight, 'age': age, 'fat': fat, 'sex': gender}

def run_single_simulation_for_temp(met_value, env_conditions, participant, clo_value, duration_minutes):
    """
    Runs a single JOS-3 simulation for a fixed duration and returns the 
    final core temperature. This is a simplified, non-iterative 
    version used by the MET solver.
    """
    jos3_model = JOS3(
        height=participant['height'],
        weight=participant['weight'],
        age=participant['age'],
        fat=participant['fat'],
        sex=participant['sex']
    )
    jos3_model.t_core[:] = 37.0
    jos3_model.par = met_value
    jos3_model.clo = clo_value
    jos3_model.tdb = env_conditions['tdb']
    jos3_model.tr = env_conditions['mrt']
    jos3_model.v = env_conditions['v']
    jos3_model.rh = env_conditions['rh']

    jos3_model.simulate(times=int(duration_minutes))

    return jos3_model.t_core.mean()


def find_met_for_target_temp(target_temp, env_conditions, participant, clo_value, duration_minutes):
    """
    Uses a bisection method (binary search) to find the MET value that
    results in a specific target core temperature.
    
    This function answers: "What is the max MET value someone can
    sustain to stay *below* target_temp?"
    """
    met_low = 1.0  # Resting
    met_high = 20.0 # Max exertion

    # First, check if even max exertion can reach the target temp.
    t_high = run_single_simulation_for_temp(met_high, env_conditions, participant, clo_value, duration_minutes)
    if t_high < target_temp:
        return met_high # Return the max possible MET (it's safe)

    # Check if resting already exceeds the target temp.
    t_low = run_single_simulation_for_temp(met_low, env_conditions, participant, clo_value, duration_minutes)
    if t_low > target_temp:
        return met_low # Return the min MET (even resting is too hot)

    # Bisection search
    for _ in range(5): # 5 iterations is precise enough
        met_guess = (met_low + met_high) / 2
        t_guess = run_single_simulation_for_temp(met_guess, env_conditions, participant, clo_value, duration_minutes)

        if t_guess < target_temp:
            met_low = met_guess
        else:
            met_high = met_guess

    return (met_low + met_high) / 2


def analyze_met_thresholds(interp_data, lat, lon, clo_value):
    """
    Analyzes and calculates the maximum permissible MET for different
    age/gender groups to stay below specific core temperature thresholds.
    
    This function iterates through time, age groups, genders, and
    temp thresholds to build a "safe activity" profile.
    
    Returns:
    --------
    pd.DataFrame : A DataFrame containing the permissible MET for
                   each combination.
    """
    print("\nStarting analysis of safe MET thresholds...")

    age_groups = {
        "18–29": 25,
        "30–39": 35,
        "40–49": 45,
        "50–59": 55,
        "60–65": 62
    }
    genders = ['male', 'female']
    temp_thresholds = [39.0, 39.5, 40.0, 41.0]
    results = []

    # Prepare detailed environmental conditions once
    aqi = get_air_quality(lat, lon)
    detailed_env = []
    for entry in interp_data:
        rad = calculate_solar_radiance(lat, lon, str(entry['time']), entry['clouds'], aqi)
        wind_1_5m = wind_speed_at_height(entry['wind'], 10, 1.5)
        gt = calculate_globe_temperature(entry['temp'], rad['ghi'], wind_1_5m, rad['solar_elevation'], entry['pressure'], entry['clouds'], aqi)
        mrt = calculate_mrt(gt, entry['temp'], wind_1_5m, rad['ghi'], rad['solar_elevation'])
        detailed_env.append({
            'time': entry['time'],
            'tdb': entry['temp'],
            'mrt': mrt,
            'v': max(0.1, wind_1_5m),
            'rh': entry['rh']
        })

    # Main calculation loop
    total_calculations = len(detailed_env) * len(age_groups) * len(genders) * len(temp_thresholds)
    with tqdm(total=total_calculations, desc="Calculating MET Thresholds") as pbar:
        for i, env_step in enumerate(detailed_env):
            # The duration is the time elapsed since the start
            duration_minutes = (env_step['time'] - detailed_env[0]['time']).total_seconds() / 60
            if duration_minutes == 0: duration_minutes = 1 # Avoid zero duration

            for age_label, age_val in age_groups.items():
                for gender in genders:
                    participant = get_representative_participant(age_val, gender)
                    for target_temp in temp_thresholds:
                        
                        # Find the MET value
                        permissible_met = find_met_for_target_temp(
                            target_temp, env_step, participant, clo_value, duration_minutes
                        )
                        results.append({
                            'time': env_step['time'],
                            'age_group': age_label,
                            'gender': gender,
                            'temp_threshold': target_temp,
                            'permissible_met': permissible_met
                        })
                        pbar.update(1)

    return pd.DataFrame(results)

def plot_met_thresholds(df_met, user_selected_met):
    """
    Plots the permissible MET values for each age group and gender,
    with the user's selected activity as a reference line.
    """
    sns.set(style="whitegrid")
    age_groups = sorted(df_met['age_group'].unique())
    n_groups = len(age_groups)

    # Create a subplot for each age group
    fig, axes = plt.subplots(n_groups, 1, figsize=(12, 5 * n_groups), sharex=True, sharey=True)
    if n_groups == 1: # If only one group, axes is not a list
        axes = [axes]

    # Define colors and styles
    temp_colors = {39.0: 'blue', 39.5: 'green', 40.0: 'orange', 41.0: 'red'}
    gender_styles = {'male': '-', 'female': '--'}

    for i, age_group in enumerate(age_groups):
        ax = axes[i]
        df_group = df_met[df_met['age_group'] == age_group]

        for gender in ['male', 'female']:
            df_gender = df_group[df_group['gender'] == gender]
            for temp, color in temp_colors.items():
                df_temp = df_gender[df_gender['temp_threshold'] == temp]
                if not df_temp.empty:
                    label = f'{gender.capitalize()} < {temp}°C'
                    ax.plot(df_temp['time'], df_temp['permissible_met'],
                            label=label, color=color, linestyle=gender_styles[gender], marker='o', markersize=3)

        # Plot the user-selected MET as a reference line
        ax.axhline(y=user_selected_met, color='black', linestyle=':', linewidth=2.5, label=f'Chosen Activity (MET: {user_selected_met})')

        ax.set_title(f'Permissible Activity Intensity for Age Group: {age_group}', fontsize=14)
        ax.set_ylabel('MET Value', fontsize=12)
        ax.legend(title="Legend", bbox_to_anchor=(1.02, 1), loc='upper left')
        ax.grid(True, which='both', linestyle='--', linewidth=0.5)
        ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))

    axes[-1].set_xlabel("Time", fontsize=12)
    plt.ylim(bottom=1)
    fig.suptitle('Analysis of Maximum Permissible MET Values', fontsize=18, weight='bold')
    plt.tight_layout(rect=[0, 0, 0.85, 0.96]) # Adjust layout
    plt.show()


# =============================================================================
#                    USER INPUT FUNCTIONS
# =============================================================================

def select_met_activity(activity_dict):
    """Displays a menu for activity choice and returns MET and speed."""
    print("\nChoose an activity:")
    for key, activity in activity_dict.items():
        print(f"{key}. {activity['description']} (MET: {activity['met']})")
    while True:
        try:
            choice = int(input("Enter the activity number: "))
            if choice in activity_dict:
                selected = activity_dict[choice]
                return choice, selected["met"], selected["speed_kmh"] * 1000 / 3600
            print("Invalid choice.")
        except ValueError:
            print("Please enter a valid number.")


def select_clo_value(clo_dict):
    """Displays a menu for clothing choice."""
    print("\nChoose a clothing option:")
    for key, option in clo_dict.items():
        print(f"{key}. {option['description']} (clo: {option['clo']})")
    while True:
        try:
            choice = int(input("Enter the clothing option number: "))
            if choice in clo_dict:
                return clo_dict[choice]["clo"]
            print("Invalid choice.")
        except ValueError:
            print("Please enter a valid number.")


def select_age_configuration():
    """Lets the user choose an age simulation method for adults."""
    print("\nChoose an age simulation method for adults:")
    print("1. Standard distribution (normal distribution, 18-65 years, mean 35)")
    print("2. Specific age group")
    while True:
        choice = input("Enter your choice (1 or 2): ")
        if choice == '1':
            return "standard"
        elif choice == '2':
            age_groups = {'1': (18, 29), '2': (30, 39), '3': (40, 49), '4': (50, 59), '5': (60, 65)}
            print("\nChoose a specific age group:")
            for k, v in age_groups.items(): print(f"{k}. {v[0]}-{v[1]} years")
            while True:
                group_choice = input("Enter the age group number: ")
                if group_choice in age_groups:
                    return age_groups[group_choice]
                print("Invalid choice. Please try again.")
        else:
            print("Invalid choice. Please enter 1 or 2.")


def get_adaptation_profile(activity_choice):
    """Determines the adaptation profile for adults (training & acclimatization)."""
    profiles = {
        1: {"name": "Beginner / Not acclimatized", "training": 0.0, "acclimatization": 0.0},
        2: {"name": "Low-average / Partially acclimatized", "training": 0.25, "acclimatization": 0.3},
        3: {"name": "Average / Well-acclimatized", "training": 0.5, "acclimatization": 0.6},
        4: {"name": "Advanced / Fully acclimatized", "training": 1.0, "acclimatization": 1.0}
    }

    # Recommend a profile based on activity intensity
    if activity_choice in [6, 7, 8, 9, 10]: recommended_profile_key = 4 # Professional
    elif activity_choice in [1, 2, 3, 4, 5, 11]: recommended_profile_key = 3 # Recreational running
    elif activity_choice in [15, 16, 17]: recommended_profile_key = 2 # Fitness walking
    else: recommended_profile_key = 1 # Light walking

    recommended_profile = profiles[recommended_profile_key]
    print(f"\n{Fore.CYAN}Recommended adaptation profile for this activity: {recommended_profile['name']}{Style.RESET_ALL}")

    while True:
        use_recommendation = input("Do you want to use this profile? (y/n): ").lower().strip()
        if use_recommendation in ['y', 'yes', '']:
            return recommended_profile
        elif use_recommendation in ['n', 'no']:
            print("\nChoose a profile manually:")
            for key, val in profiles.items(): print(f"{key}. {val['name']}")
            while True:
                try:
                    manual_choice = int(input("Enter the number of your choice: "))
                    if manual_choice in profiles: return profiles[manual_choice]
                    print("Invalid choice.")
                except ValueError: print("Please enter a valid number.")
        else:
            print("Invalid input. Please enter 'y' or 'n'.")


def clear_all_caches():
    """Clears the caches of all @lru_cache decorated functions."""
    get_lat_lon.cache_clear()
    get_timezone.cache_clear()
    get_weather_forecast.cache_clear()
    get_air_quality.cache_clear()
    calculate_solar_radiance.cache_clear()
    print("All function caches have been cleared.")

def calculate_and_export_wbgt(city_name, lat, lon, apply_uhi=False, population=None):
    """Calculates WBGT for the next 5 days and saves it to an Excel file, with optional UHI effect."""
    print(f"\n--- Calculating WBGT for {city_name} for the next 5 days ---")
    if apply_uhi:
        print(f"UHI effect will be applied with a population of {population}.")

    # Current date for the tab name
    current_date = datetime.now().strftime('%Y-%m-%d')
    sheet_name = f"{city_name.replace(' ', '_')}_{current_date}"
    excel_filename = "HESTIA_Simulation_Results.xlsx" # Changed filename

    # Get weather data for 5 days
    weather_data = get_weather_forecast(lat, lon)
    if not weather_data:
        print(f"{Fore.RED}Could not retrieve weather data for {city_name}.{Style.RESET_ALL}")
        return

    # Filter and interpolate data to hourly basis
    start_dt = pd.Timestamp.now(tz=UTC)
    end_dt = start_dt + timedelta(days=5)
    interp_data = interpolate_weather(weather_data, start_dt, end_dt, interval_minutes=60)  # Hourly

    # Apply UHI effect if selected
    if apply_uhi:
        for entry in interp_data:
            is_daytime = 6 <= entry["time"].hour < 18
            uhi_effect = calculate_uhi_effect(population, entry["wind"], is_daytime)
            entry["temp"] += uhi_effect
            #print(f"DEBUG: Time: {entry['time'].strftime('%Y-%m-%d %H:%M')}, Is_daytime: {is_daytime}, Wind: {entry['wind']:.1f}, UHI-effect: {uhi_effect}")

    # Calculate WBGT for each hour
    wbgt_results = []
    aqi = get_air_quality(lat, lon)
    for entry in interp_data:
        time = entry["time"]
        temp = entry["temp"]
        rh = entry["rh"]
        wind = entry["wind"]
        clouds = entry["clouds"]
        pressure = entry["pressure"]
        twb = entry["twb"]

        # Calculate globe temp and MRT
        radiance = calculate_solar_radiance(lat, lon, str(time), clouds, aqi)
        wind_1_5m = wind_speed_at_height(wind, 10, 1.5)
        globe_temp = calculate_globe_temperature(temp, radiance['ghi'], wind_1_5m, radiance['solar_elevation'], pressure, clouds, aqi)
        mrt = calculate_mrt(globe_temp, temp, wind_1_5m, radiance['ghi'], radiance['solar_elevation'])

        # Calculate WBGT
        with_solar_load = bool(radiance['ghi'] > 0 and radiance['solar_elevation'] > 0)
        wbgt_args = {
            "twb": twb,
            "tg": globe_temp,
            "with_solar_load": with_solar_load,
            "round_output": True
        }
        if with_solar_load:
            wbgt_args["tdb"] = temp
        wbgt_result = wbgt(**wbgt_args)
        wbgt_val = float(wbgt_result.wbgt)

        # Calculate UHI effect specifically for this iteration
        uhi_effect = calculate_uhi_effect(population, wind, 6 <= time.hour < 18) if apply_uhi else 0.0

        wbgt_results.append({
            "time": time.strftime('%Y-%m-%d %H:%M'),
            "temperature": temp,
            "relative_humidity": rh,
            "wind_speed": wind,
            "cloud_cover": clouds,
            "pressure": pressure,
            "wet_bulb_temp": twb,
            "globe_temp": globe_temp,
            "mrt": mrt,
            "wbgt": wbgt_val,
            "uhi_effect_applied": uhi_effect
        })

    # Export to Excel
    print(f"\n[INFO] Exporting WBGT data to '{excel_filename}', sheet: '{sheet_name}'...")
    try:
        if os.path.exists(excel_filename):
            with pd.ExcelWriter(excel_filename, engine='openpyxl', mode='a', if_sheet_exists='replace') as writer:
                wbgt_df = pd.DataFrame(wbgt_results)
                wbgt_df.to_excel(writer, sheet_name=sheet_name, index=False)
        else:
            with pd.ExcelWriter(excel_filename, engine='openpyxl', mode='w') as writer:
                wbgt_df = pd.DataFrame(wbgt_results)
                wbgt_df.to_excel(writer, sheet_name=sheet_name, index=False)
        print(f"{Fore.GREEN}[SUCCESS] WBGT data for {city_name} successfully exported.{Style.RESET_ALL}")
    except Exception as e:
        print(f"{Fore.RED}[ERROR] Could not export to Excel. Error: {e}{Style.RESET_ALL}")
        
        
# =============================================================================
#                    MAIN FUNCTION
# =============================================================================

def main():
    """Main function to run the entire simulation pipeline or WBGT calculation."""
    plt.close('all')
    clear_all_caches()

    init(autoreset=True)
    print(f"{Style.BRIGHT}HESTIA: Integrated Thermal Simulation Tool (rev02){Style.RESET_ALL}")

    try:
        # --- Mode Selection ---
        while True:
            print("\nSelect the simulation mode:")
            print("1. Adults (Thermal Simulation)")
            print("2. Children (Thermal Simulation)")
            print("3. WBGT Calculation (5-day forecast)")
            sim_mode = input("Enter your choice (1, 2, or 3): ").strip()
            if sim_mode in ['1', '2', '3']:
                sim_mode = 'adult' if sim_mode == '1' else 'child' if sim_mode == '2' else 'wbgt'
                break
            else:
                print(f"{Fore.RED}Invalid choice. Please enter '1', '2', or '3'.{Style.RESET_ALL}")

        print(f"\n--- Mode selected: {sim_mode.upper()} ---")

        # --- General Inputs ---
        city_name = input("Enter the city name (e.g., Amsterdam): ")
        lat, lon = get_lat_lon(city_name)
        if lat is None or lon is None:
            print(f"{Fore.RED}Could not retrieve coordinates for {city_name}.{Style.RESET_ALL}")
            return

        # --- UHI Input (for all modes) ---
        apply_uhi = input("Apply Urban Heat Island (UHI) effect? (y/n): ").lower() == 'y'
        population = None
        if apply_uhi:
            population = int(input("Enter the city's population (e.g., 800000 for Amsterdam): "))

        if sim_mode == 'wbgt':
            # Run WBGT calculation and export
            calculate_and_export_wbgt(city_name, lat, lon, apply_uhi, population)
            return

        # --- Existing code for adult/child modes ---
        weather_data = get_weather_forecast(lat, lon)
        if not weather_data: return

        # --- Print Raw Weather Data ---
        print("\n--- Raw Weather Forecast Summary (from Open-Meteo) ---")
        print("{:<20} {:<10} {:<10} {:<10}".format("Time (UTC)", "Temp (°C)", "RH (%)", "Wind (m/s)"))
        print("-" * 55)
        for entry in weather_data[:5]:
            dt_utc = datetime.fromtimestamp(entry["dt"], tz=UTC)
            print("{:<20} {:<10.1f} {:<10.0f} {:<10.1f}".format(
                dt_utc.strftime('%Y-%m-%d %H:%M'),
                entry["main"]["temp"],
                entry["main"]["humidity"],
                entry["wind"]["speed"]
            ))
        print("...")

        available_dates = sorted(list(set([pd.Timestamp(datetime.fromtimestamp(entry["dt"], tz=UTC)).date() for entry in weather_data])))
        print("\nAvailable forecast dates:")
        date_options = [f"{i+1}. {date.strftime('%Y-%m-%d')}" for i, date in enumerate(available_dates)]
        print("\n".join(date_options))

        date_choice = int(input("Choose a number for the date: ")) - 1
        date_str = available_dates[date_choice].strftime('%Y-%m-%d')

        print(f"\nDate selected: {date_str}. Please provide event details.")
        start_time_str = input("Enter start time (HH:MM): ")
        duration = float(input("Enter event duration in hours (e.g., 1.5): "))
        n_simulations = int(input("Enter the number of simulated participants (e.g., 5000 for high accuracy): "))

        # --- Mode-specific Inputs ---
        if sim_mode == 'adult':
            activity_choice, met_value, _ = select_met_activity(MET_ACTIVITIES_ADULT)
            adaptation_profile = get_adaptation_profile(activity_choice)
            training_factor = adaptation_profile['training']
            acclimatization_factor = adaptation_profile['acclimatization']
            clo_value = select_clo_value(CLO_OPTIONS_ADULT)
            age_config = select_age_configuration()
        else: # child mode
            age_group_choice = input("Select age group (1: 0-10 years, 2: 11-20 years): ")
            age_config = "0-10" if age_group_choice == '1' else "11-20"
            _, met_value, _ = select_met_activity(MET_ACTIVITIES_CHILD)
            fitness_choice = input("Select a general fitness/acclimatization level (1: Low, 2: Medium, 3: High): ")
            fitness_map = {'1': 0.2, '2': 0.5, '3': 0.8}
            fitness_factor = fitness_map.get(fitness_choice, 0.5)
            clo_value = select_clo_value(CLO_OPTIONS_CHILD)

        # --- Data Preparation ---
        local_timezone = get_timezone(lat, lon)
        start_dt = pd.Timestamp(f"{date_str} {start_time_str}", tz=local_timezone.zone)
        end_dt = start_dt + timedelta(hours=duration)
        
        interp_data = interpolate_weather(weather_data, start_dt, end_dt)

        if apply_uhi:
            print(f"\nApplying UHI effect for {city_name}...")
            for entry in interp_data:
                is_daytime = 6 <= entry["time"].hour < 18
                uhi_effect = calculate_uhi_effect(population, entry["wind"], is_daytime)
                entry["temp"] += uhi_effect

        print("\nInterpolated weather data prepared for simulation.")

        # --- Run Simulation ---
        print(f"\nStarting simulation for {n_simulations} participants in {city_name}...")
        if sim_mode == 'adult':
            all_results, stats, results_df = run_monte_carlo_adult(
                interp_data, lat, lon, met_value, clo_value, n_simulations,
                age_config, training_factor, acclimatization_factor, use_parallel=True
            )
        else: # child mode
            all_results, stats = run_monte_carlo_pediatric(
                interp_data, lat, lon, met_value, clo_value, n_simulations,
                age_config, fitness_factor, use_parallel=True
            )

        if not all_results:
            print("No results were calculated.")
            return
        
        # --- Export to Excel (only for adult mode) ---
        if sim_mode == 'adult' and results_df is not None:
            excel_filename = "HESTIA_Simulation_Results.xlsx"
            sheet_name = f"{city_name.replace(' ', '_')}_{start_dt.strftime('%Y-%m-%d')}"
            
            print(f"\n[INFO] Exporting data to Excel file: '{excel_filename}', sheet: '{sheet_name}'...")
            
            try:
                if os.path.exists(excel_filename):
                    with pd.ExcelWriter(excel_filename, engine='openpyxl', mode='a', if_sheet_exists='replace') as writer:
                        results_df.to_excel(writer, sheet_name=sheet_name, index=False)
                else:
                    with pd.ExcelWriter(excel_filename, engine='openpyxl', mode='w') as writer:
                        results_df.to_excel(writer, sheet_name=sheet_name, index=False)
                
                print(f"{Fore.GREEN}[SUCCESS] Detailed data for {len(results_df)} participants successfully exported.{Style.RESET_ALL}")

            except Exception as e:
                print(f"{Fore.RED}[ERROR] Could not export to Excel. Error: {e}{Style.RESET_ALL}")

        # --- Print Interpolated Data Used in Simulation ---
        print("\n--- Interpolated Environmental Data Used in Simulation ---")
        print("{:<20} {:<10} {:<10} {:<15} {:<10} {:<10}".format("Time", "Temp (°C)", "RH (%)", "TWB (°C)", "Wind (m/s)", "MRT (°C)"))
        print("-" * 80)

        first_sim_results = all_results[0]
        for i, entry in enumerate(interp_data):
            print("{:<20} {:<10.1f} {:<10.0f} {:<15.1f} {:<10.1f} {:<10.1f}".format(
                entry["time"].strftime('%Y-%m-%d %H:%M'),
                entry["temp"],
                entry["rh"],
                entry["twb"],
                entry["wind"],
                first_sim_results[i]['mrt']
            ))

        # --- Display Results ---
        if sim_mode == 'adult':
            print(f"\n=== Adult Risk Classification Summary (based on 95th Percentile) ===")
            print("{:<20} {:<10} {:<10} {:<15} {:<10} {:<40}".format(
                "Time", "UTCI", "WBGT", "T_rect(95%)", "RPE(95%)", "Overall Risk (U/W/T/RPE)"
            ))
            print("-" * 105)
            for i, r_point in enumerate(all_results[0]):
                risk = calculate_adult_risk_classification(r_point['utci'], r_point['wbgt'], stats['upper_t_rect'][i], stats['upper_rpe'][i])
                print(f"{r_point['time']:<20} {r_point['utci']:<10.2f} {r_point['wbgt']:<10.2f} {stats['upper_t_rect'][i]:<15.2f} "
                      f"{stats['upper_rpe'][i]:<10.2f} {risk['risk_color']}{risk['detailed_risk']}")

            print(f"\n=== Core Temperature Risk Threshold Analysis (T_rect) ===")
            thresholds = sorted([float(k) for k in stats['temp_threshold_stats'].keys()])
            header = "{:<20}".format("Time") + "".join([" {:<25}".format(f"% > {t}°C (95% CI)") for t in thresholds])
            print(header)
            print("-" * len(header))
            for i, r_point in enumerate(all_results[0]):
                row = "{:<20}".format(r_point['time'])
                for t in thresholds:
                    t_str = f"{t:.1f}"
                    mean = stats['temp_threshold_stats'][t_str]['mean'][i]
                    lower = stats['temp_threshold_stats'][t_str]['ci_lower'][i]
                    upper = stats['temp_threshold_stats'][t_str]['ci_upper'][i]
                    cell = f"{mean:8.4f} ({lower:8.4f}-{upper:8.4f})" # Use 4 decimal places
                    row += " {:<25}".format(cell)
                print(row)

            # Plot results
            plot_adult_results(all_results, stats, city_name, start_dt, duration)
            if results_df is not None:
                plot_adult_boxplots(results_df)

            # Run and plot MET threshold analysis
            df_met_analysis = analyze_met_thresholds(interp_data, lat, lon, clo_value)
            plot_met_thresholds(df_met_analysis, met_value)

        else: # child mode
            print(f"\n=== Pediatric Risk Classification Summary (based on 95th Percentile) ===")
            print("{:<20} {:<10} {:<10} {:<15} {:<10} {:<15} {:<40}".format(
                "Time", "UTCI", "WBGT", "T_core(95%)", "RPE(95%)", "% First Aid", "Overall Risk (U/W/T/RPE)"
            ))
            print("-" * 130)
            for i, r_point in enumerate(all_results[0]):
                risk = calculate_pediatric_risk_classification(r_point['utci'], r_point['wbgt'], stats['upper_t_core'][i], stats['upper_rpe'][i])
                print(f"{r_point['time']:<20} {r_point['utci']:<10.2f} {r_point['wbgt']:<10.2f} {stats['upper_t_core'][i]:<15.2f} "
                      f"{stats['upper_rpe'][i]:<10.2f} {stats['percent_first_aid'][i]:<15.1f} "
                      f"{risk['risk_color']}{risk['detailed_risk']}")

            print(f"\n=== Core Temperature Risk Threshold Analysis (T_core) ===")
            thresholds = sorted([float(k) for k in stats['temp_threshold_stats'].keys()])
            header = "{:<20}".format("Time") + "".join([" {:<25}".format(f"% > {t}°C (95% CI)") for t in thresholds])
            print(header)
            print("-" * len(header))
            for i, r_point in enumerate(all_results[0]):
                row = "{:<20}".format(r_point['time'])
                for t in thresholds:
                    t_str = f"{t:.1f}"
                    mean = stats['temp_threshold_stats'][t_str]['mean'][i]
                    lower = stats['temp_threshold_stats'][t_str]['ci_lower'][i]
                    upper = stats['temp_threshold_stats'][t_str]['ci_upper'][i]
                    cell = f"{mean:8.4f} ({lower:8.4f}-{upper:8.4f})" # Use 4 decimal places
                    row += " {:<25}".format(cell)
                print(row)

            # Plot results
            plot_pediatric_results(all_results, stats, city_name, start_dt, duration)

        input("\nPress Enter to close the plot windows and exit.")

    except ValueError as e:
        import traceback
        traceback.print_exc()
        print(f"{Fore.RED}Invalid input error: {e}{Style.RESET_ALL}")

    except Exception as e:
        import traceback
        traceback.print_exc()
        print(f"{Fore.RED}An unexpected error occurred: {e}{Style.RESET_ALL}")
if __name__ == "__main__":
    main()
